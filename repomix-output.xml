This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    code-quality.mdc
    performance.mdc
    python-core.mdc
    security.mdc
    testing.mdc
01_asyncio_basics.py
02_websocket_basics.py
03_realtime_chat.py
04_advanced_websocket.py
package.json
quick_websocket_test.py
README.md
requirements.txt
simple_websocket_test.py
test_websocket.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/code-quality.mdc">
---
globs: *.py
description: Code quality and style enforcement rules for Python
---

# Python Code Quality & Style Rules

## üéØ STYLE ENFORCEMENT - MANDATORY

### **PEP 8 Compliance - ZERO TOLERANCE**

- **ALWAYS** use 4 spaces for indentation (never tabs)
- **ALWAYS** limit lines to 88 characters (Black formatter standard)
- **ALWAYS** use snake_case for variables and functions
- **ALWAYS** use PascalCase for classes
- **ALWAYS** use UPPER_CASE for constants
- **NEVER** use trailing commas in single-line structures
- **NEVER** use spaces around `=` in function parameters

### **Import Organization - STRICT ORDER**

```python
# 1. Standard library imports (alphabetical)
import json
import os
import sys
from typing import Any, Dict, List, Optional

# 2. Third-party imports (alphabetical)
import pandas as pd
import requests
from django.conf import settings

# 3. Local application imports (alphabetical)
from .models import User
from .utils import format_data
from ..core.exceptions import ValidationError
```

## üö® CRITICAL QUALITY GATES

### **MANDATORY: Function Design**

- **ALWAYS** keep functions under 20 lines
- **ALWAYS** use single responsibility principle
- **ALWAYS** return early to reduce nesting
- **NEVER** use more than 4 parameters (use dataclasses for complex data)
- **NEVER** use global variables inside functions

### **MANDATORY: Class Design**

- **ALWAYS** use `__slots__` for classes with many instances
- **ALWAYS** implement `__repr__` and `__str__` methods
- **ALWAYS** use properties for computed attributes
- **NEVER** use inheritance for code reuse (prefer composition)
- **NEVER** use more than 3 levels of inheritance

### **MANDATORY: Error Handling**

```python
# ‚úÖ CORRECT - Specific exception handling
try:
    result = risky_operation()
except SpecificError as e:
    logger.error(f"Operation failed: {e}")
    return None
except AnotherError as e:
    logger.warning(f"Non-critical failure: {e}")
    return default_value

# ‚ùå WRONG - Bare except
try:
    result = risky_operation()
except:  # NEVER DO THIS
    pass
```

## üîß CODE PATTERNS - ENFORCED

### **String Handling**

```python
# ‚úÖ CORRECT - f-strings for formatting
name = "John"
message = f"Hello, {name}!"

# ‚úÖ CORRECT - join() for concatenation
words = ["hello", "world", "python"]
sentence = " ".join(words)

# ‚ùå WRONG - String concatenation in loops
result = ""
for word in words:
    result += word + " "  # Inefficient!
```

### **List and Dictionary Operations**

```python
# ‚úÖ CORRECT - List comprehensions
squares = [x**2 for x in range(10) if x % 2 == 0]

# ‚úÖ CORRECT - Dictionary comprehensions
user_ages = {user.name: user.age for user in users if user.age > 18}

# ‚úÖ CORRECT - Generator expressions for large datasets
large_sum = sum(x**2 for x in range(1000000))

# ‚ùå WRONG - Unnecessary list creation
large_sum = sum([x**2 for x in range(1000000)])  # Creates unnecessary list
```

### **Context Managers - MANDATORY**

```python
# ‚úÖ CORRECT - Always use context managers
with open('file.txt', 'r') as f:
    content = f.read()

# ‚úÖ CORRECT - Custom context managers
from contextlib import contextmanager

@contextmanager
def database_connection():
    conn = get_connection()
    try:
        yield conn
    finally:
        conn.close()

# ‚ùå WRONG - Manual resource management
f = open('file.txt', 'r')
content = f.read()
f.close()  # May not execute if exception occurs
```

## üö´ ABSOLUTE PROHIBITIONS

### **NEVER USE THESE PATTERNS:**

- ‚ùå `eval()` or `exec()` with any user input
- ‚ùå `globals()` or `locals()` for variable access
- ‚ùå `import *` in any module
- ‚ùå Mutable default arguments: `def func(items=[]):`
- ‚ùå Bare `except:` clauses
- ‚ùå `==` for None comparison (use `is None`)
- ‚ùå `print()` for logging (use proper logging)
- ‚ùå Global variables for state management

### **ANTI-PATTERNS TO AVOID:**

```python
# ‚ùå WRONG - Mutable default argument
def add_item(item, items=[]):
    items.append(item)
    return items

# ‚úÖ CORRECT - Use None as default
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items

# ‚ùå WRONG - String concatenation in loop
result = ""
for item in items:
    result += str(item)

# ‚úÖ CORRECT - Use join()
result = "".join(str(item) for item in items)
```

## üìä PERFORMANCE REQUIREMENTS

### **Memory Efficiency**

- Use generators for large datasets
- Implement `__slots__` for classes with many instances
- Use `collections.namedtuple` for simple data structures
- Prefer `pathlib.Path` over `os.path`

### **CPU Efficiency**

- Use list comprehensions over explicit loops
- Prefer `enumerate()` over manual indexing
- Use `collections.defaultdict` for counting
- Cache expensive computations with `functools.lru_cache`

### **I/O Efficiency**

- Use async/await for I/O-bound operations
- Batch database operations
- Use connection pooling
- Implement proper caching strategies

## üß™ TESTING REQUIREMENTS

### **Test Structure**

```python
import pytest
from unittest.mock import Mock, patch

class TestUserService:
    """Test suite for UserService class."""

    def setup_method(self):
        """Set up test fixtures before each test method."""
        self.user_service = UserService()
        self.mock_user = Mock()

    def test_create_user_success(self):
        """Test successful user creation."""
        # Arrange
        user_data = {"name": "John", "email": "john@example.com"}

        # Act
        result = self.user_service.create_user(user_data)

        # Assert
        assert result.name == "John"
        assert result.email == "john@example.com"

    def test_create_user_invalid_email(self):
        """Test user creation with invalid email."""
        # Arrange
        user_data = {"name": "John", "email": "invalid-email"}

        # Act & Assert
        with pytest.raises(ValidationError):
            self.user_service.create_user(user_data)
```

### **Test Coverage Requirements**

- **MANDATORY**: >90% code coverage
- **MANDATORY**: Test all public methods
- **MANDATORY**: Test both success and failure scenarios
- **MANDATORY**: Mock all external dependencies
- **MANDATORY**: Test edge cases and boundary conditions

## üîç CODE REVIEW CHECKLIST

### **Before Submitting Code:**

- [ ] All functions have type hints
- [ ] All public functions have docstrings
- [ ] Code follows PEP 8 (run `black` and `flake8`)
- [ ] No bare `except:` clauses
- [ ] All imports are organized correctly
- [ ] No hardcoded secrets or credentials
- [ ] Proper error handling for all external calls
- [ ] Unit tests cover all new functionality
- [ ] No performance anti-patterns
- [ ] Memory usage is optimized for large datasets
</file>

<file path=".cursor/rules/performance.mdc">
---
globs: *.py
description: Performance optimization rules for Python development
---

# Python Performance Rules

## üöÄ CRITICAL PERFORMANCE REQUIREMENTS

### **MEMORY EFFICIENCY - MANDATORY**

- **ALWAYS** use generators for large datasets instead of lists
- **ALWAYS** implement `__slots__` for classes with many instances
- **ALWAYS** use `collections.namedtuple` for simple data structures
- **NEVER** load entire files into memory if processing line by line
- **NEVER** create unnecessary intermediate lists

### **CPU EFFICIENCY - MANDATORY**

- **ALWAYS** use list comprehensions over explicit loops when appropriate
- **ALWAYS** prefer `enumerate()` over manual indexing
- **ALWAYS** use `collections.defaultdict` for counting operations
- **ALWAYS** cache expensive computations with `functools.lru_cache`
- **NEVER** use string concatenation in loops

### **I/O EFFICIENCY - MANDATORY**

- **ALWAYS** use async/await for I/O-bound operations
- **ALWAYS** batch database operations
- **ALWAYS** use connection pooling
- **NEVER** make synchronous calls in async functions
- **NEVER** open/close connections in loops

## ‚ö° PERFORMANCE PATTERNS - ENFORCED

### **Memory Optimization**

```python
# ‚úÖ CORRECT - Generator for large datasets
def process_large_file(filename: str) -> Generator[str, None, None]:
    """Process large file line by line without loading into memory."""
    with open(filename, 'r') as f:
        for line in f:
            yield process_line(line)

# ‚úÖ CORRECT - Using __slots__ for memory efficiency
class Point:
    __slots__ = ['x', 'y', 'z']

    def __init__(self, x: float, y: float, z: float):
        self.x = x
        self.y = y
        self.z = z

# ‚úÖ CORRECT - Namedtuple for simple data
from collections import namedtuple
User = namedtuple('User', ['id', 'name', 'email'])

# ‚ùå WRONG - Loading entire file into memory
def process_large_file_wrong(filename: str) -> List[str]:
    with open(filename, 'r') as f:
        lines = f.readlines()  # Loads entire file into memory
    return [process_line(line) for line in lines]
```

### **CPU Optimization**

```python
# ‚úÖ CORRECT - List comprehension
squares = [x**2 for x in range(1000) if x % 2 == 0]

# ‚úÖ CORRECT - Generator expression for large datasets
large_sum = sum(x**2 for x in range(1000000))

# ‚úÖ CORRECT - Using enumerate
for i, item in enumerate(items):
    process_item(i, item)

# ‚úÖ CORRECT - Using defaultdict for counting
from collections import defaultdict
word_count = defaultdict(int)
for word in words:
    word_count[word] += 1

# ‚ùå WRONG - Inefficient string concatenation
result = ""
for word in words:
    result += word + " "  # Creates new string each time

# ‚úÖ CORRECT - Using join()
result = " ".join(words)
```

### **Caching and Memoization**

```python
from functools import lru_cache, wraps
from typing import Callable, Any
import time

# ‚úÖ CORRECT - LRU cache for expensive computations
@lru_cache(maxsize=128)
def fibonacci(n: int) -> int:
    """Calculate Fibonacci number with caching."""
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# ‚úÖ CORRECT - Custom caching decorator
def cache_result(func: Callable) -> Callable:
    """Cache function results based on arguments."""
    cache = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
        key = str(args) + str(sorted(kwargs.items()))
        if key not in cache:
            cache[key] = func(*args, **kwargs)
        return cache[key]

    return wrapper

@cache_result
def expensive_calculation(data: List[int]) -> float:
    """Expensive calculation that benefits from caching."""
    time.sleep(1)  # Simulate expensive operation
    return sum(x**2 for x in data) / len(data)
```

## üîÑ ASYNC/AWAIT PATTERNS

### **Proper Async Implementation**

```python
import asyncio
import aiohttp
from typing import List, Dict, Any

# ‚úÖ CORRECT - Async function for I/O operations
async def fetch_data(url: str) -> Dict[str, Any]:
    """Fetch data asynchronously."""
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.json()

# ‚úÖ CORRECT - Batch async operations
async def fetch_multiple_urls(urls: List[str]) -> List[Dict[str, Any]]:
    """Fetch multiple URLs concurrently."""
    tasks = [fetch_data(url) for url in urls]
    return await asyncio.gather(*tasks)

# ‚úÖ CORRECT - Async context manager
class AsyncDatabaseConnection:
    async def __aenter__(self):
        self.conn = await get_async_connection()
        return self.conn

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.conn.close()

# ‚ùå WRONG - Blocking operations in async function
async def bad_async_function():
    # This blocks the event loop
    result = requests.get('https://api.example.com')  # Synchronous call
    return result.json()
```

### **Database Optimization**

```python
import asyncio
from typing import List, Dict, Any

# ‚úÖ CORRECT - Batch database operations
async def batch_insert_users(users: List[Dict[str, Any]]) -> None:
    """Insert multiple users in a single transaction."""
    async with get_async_connection() as conn:
        async with conn.transaction():
            await conn.executemany(
                "INSERT INTO users (name, email) VALUES ($1, $2)",
                [(user['name'], user['email']) for user in users]
            )

# ‚úÖ CORRECT - Connection pooling
class DatabasePool:
    def __init__(self, max_connections: int = 10):
        self.semaphore = asyncio.Semaphore(max_connections)
        self.connections = []

    async def get_connection(self):
        await self.semaphore.acquire()
        if self.connections:
            return self.connections.pop()
        return await create_connection()

    async def return_connection(self, conn):
        self.connections.append(conn)
        self.semaphore.release()
```

## üìä PROFILING AND MONITORING

### **Performance Monitoring**

```python
import time
import functools
from typing import Callable, Any
import logging

def profile_function(func: Callable) -> Callable:
    """Decorator to profile function execution time."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()

        execution_time = end_time - start_time
        logging.info(f"{func.__name__} executed in {execution_time:.4f} seconds")

        return result
    return wrapper

@profile_function
def process_large_dataset(data: List[int]) -> List[int]:
    """Process large dataset with performance monitoring."""
    return [x**2 for x in data if x % 2 == 0]

# Memory profiling
import tracemalloc

def profile_memory(func: Callable) -> Callable:
    """Decorator to profile memory usage."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        tracemalloc.start()
        result = func(*args, **kwargs)
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()

        logging.info(f"Memory usage - Current: {current / 1024 / 1024:.2f} MB, Peak: {peak / 1024 / 1024:.2f} MB")
        return result
    return wrapper
```

## üö´ PERFORMANCE ANTI-PATTERNS

### **NEVER USE THESE PATTERNS:**

- ‚ùå String concatenation in loops
- ‚ùå Loading entire files into memory unnecessarily
- ‚ùå Creating large intermediate lists
- ‚ùå Using synchronous I/O in async functions
- ‚ùå Opening/closing connections in loops
- ‚ùå Using `global` variables for caching
- ‚ùå Recursive functions without memoization
- ‚ùå Nested loops when alternatives exist

### **COMMON PERFORMANCE MISTAKES:**

```python
# ‚ùå WRONG - Inefficient string building
def build_string_wrong(items: List[str]) -> str:
    result = ""
    for item in items:
        result += item + ", "  # Creates new string each time
    return result

# ‚úÖ CORRECT - Efficient string building
def build_string_correct(items: List[str]) -> str:
    return ", ".join(items)

# ‚ùå WRONG - Inefficient list creation
def process_data_wrong(data: List[int]) -> List[int]:
    result = []
    for item in data:
        if item % 2 == 0:
            result.append(item * 2)
    return result

# ‚úÖ CORRECT - List comprehension
def process_data_correct(data: List[int]) -> List[int]:
    return [item * 2 for item in data if item % 2 == 0]

# ‚ùå WRONG - Synchronous I/O in async function
async def bad_async_io():
    with open('file.txt', 'r') as f:  # Blocking I/O
        return f.read()

# ‚úÖ CORRECT - Async I/O
async def good_async_io():
    async with aiofiles.open('file.txt', 'r') as f:
        return await f.read()
```

## üéØ PERFORMANCE TARGETS

### **Response Time Requirements:**

- API endpoints: < 200ms for 95th percentile
- Database queries: < 100ms for simple queries
- File I/O operations: < 50ms for files < 1MB
- Memory usage: < 100MB for typical operations

### **Scalability Requirements:**

- Support 1000+ concurrent users
- Handle 10,000+ requests per minute
- Process files up to 1GB efficiently
- Maintain < 1% error rate under load

## üìã PERFORMANCE CHECKLIST

### **Before Every Deployment:**

- [ ] All I/O operations are async where possible
- [ ] Large datasets use generators, not lists
- [ ] Database queries are optimized and batched
- [ ] Expensive computations are cached
- [ ] Memory usage is monitored and optimized
- [ ] No blocking operations in async functions
- [ ] Connection pooling is implemented
- [ ] Performance tests pass
- [ ] Memory leaks are prevented
- [ ] CPU usage is optimized
</file>

<file path=".cursor/rules/python-core.mdc">
---
alwaysApply: true
description: Core Python development rules and best practices
---

# Python Core Development Rules

## üö® CRITICAL REQUIREMENTS - NEVER VIOLATE

### **MANDATORY: Type Safety & Error Handling**

- **ALWAYS** use type hints for function parameters, return types, and class attributes
- **ALWAYS** handle exceptions with specific exception types, never bare `except:`
- **ALWAYS** use `typing.Optional` for nullable values, never `None` without explicit typing
- **NEVER** use `Any` type unless absolutely necessary - prefer specific types
- **NEVER** ignore exceptions silently - always log or handle appropriately

### **MANDATORY: Code Structure**

- **ALWAYS** follow PEP 8 style guidelines strictly
- **ALWAYS** use meaningful variable and function names (minimum 3 characters)
- **ALWAYS** write docstrings for all public functions, classes, and modules
- **NEVER** use single-letter variable names except for loop counters (i, j, k)
- **NEVER** exceed 88 characters per line (use Black formatter standard)

### **MANDATORY: Import Organization**

```python
# Standard library imports
import os
import sys
from typing import List, Dict, Optional

# Third-party imports
import requests
import pandas as pd

# Local imports
from .models import User
from .utils import validate_input
```

## üéØ OPTIMIZATION TECHNIQUES

### **Performance Critical Patterns**

- Use list comprehensions over explicit loops when appropriate
- Prefer `enumerate()` over manual indexing
- Use `collections.defaultdict` for counting operations
- Cache expensive computations with `functools.lru_cache`

### **Memory Management**

- Use generators for large datasets instead of lists
- Implement `__slots__` for classes with many instances
- Use context managers (`with` statements) for resource management
- Prefer `pathlib.Path` over `os.path` for file operations

### **Modern Python Features (3.8+)**

- Use f-strings for string formatting
- Leverage dataclasses for simple data containers
- Use walrus operator (`:=`) judiciously for assignment expressions
- Prefer `typing.Union` over `typing.Optional` for explicit union types

## üö´ ABSOLUTE PROHIBITIONS

### **NEVER DO THESE:**

- ‚ùå Use mutable default arguments: `def func(items=[]):`
- ‚ùå Use `==` to compare with `None` (use `is None` instead)
- ‚ùå Use `eval()` or `exec()` with user input
- ‚ùå Use bare `except:` clauses
- ‚ùå Use `import *` in production code
- ‚ùå Use global variables for state management
- ‚ùå Use `print()` for logging (use proper logging)
- ‚ùå Use string concatenation in loops (use `join()`)

### **SECURITY VIOLATIONS:**

- ‚ùå Never use `pickle` with untrusted data
- ‚ùå Never use `subprocess` with shell=True and user input
- ‚ùå Never store secrets in code (use environment variables)
- ‚ùå Never use weak random number generators for security

## üìã CODE QUALITY CHECKLIST

### **Before Every Commit:**

- [ ] All functions have type hints
- [ ] All public functions have docstrings
- [ ] No bare `except:` clauses
- [ ] All imports are organized correctly
- [ ] Code follows PEP 8 (run `black` and `flake8`)
- [ ] No hardcoded secrets or credentials
- [ ] Proper error handling for all external calls

### **Function Design Pattern:**

```python
def process_user_data(
    user_id: int,
    data: Dict[str, Any],
    validate: bool = True
) -> Optional[ProcessedData]:
    """
    Process user data with optional validation.

    Args:
        user_id: Unique identifier for the user
        data: Raw user data dictionary
        validate: Whether to validate data before processing

    Returns:
        ProcessedData object if successful, None if validation fails

    Raises:
        ValueError: If user_id is invalid
        DataValidationError: If data validation fails
    """
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError(f"Invalid user_id: {user_id}")

    try:
        if validate:
            validated_data = validate_user_data(data)
        else:
            validated_data = data

        return ProcessedData.from_dict(validated_data)
    except ValidationError as e:
        logger.error(f"Data validation failed: {e}")
        return None
```

## üîß DEVELOPMENT WORKFLOW

### **File Organization:**

- Keep related functionality in the same module
- Use `__init__.py` files to control package imports
- Separate configuration from business logic
- Use dependency injection for testability

### **Error Handling Strategy:**

1. **Fail Fast**: Validate inputs at function boundaries
2. **Specific Exceptions**: Create custom exception classes for business logic
3. **Graceful Degradation**: Handle external service failures gracefully
4. **Logging**: Log all errors with appropriate levels and context

### **Testing Requirements:**

- Write unit tests for all public functions
- Use pytest fixtures for test setup
- Mock external dependencies
- Aim for >90% code coverage
- Test both success and failure scenarios
</file>

<file path=".cursor/rules/security.mdc">
---
globs: *.py
description: Security-focused rules for Python development
---

# Python Security Rules

## üö® CRITICAL SECURITY REQUIREMENTS - ZERO TOLERANCE

### **INPUT VALIDATION - MANDATORY**

- **ALWAYS** validate all user inputs at application boundaries
- **ALWAYS** use allowlists instead of blocklists for validation
- **ALWAYS** sanitize data before database operations
- **NEVER** trust user input without validation
- **NEVER** use `eval()` or `exec()` with user data

### **AUTHENTICATION & AUTHORIZATION**

- **ALWAYS** use secure password hashing (bcrypt, scrypt, or Argon2)
- **ALWAYS** implement proper session management
- **ALWAYS** validate JWT tokens and check expiration
- **NEVER** store passwords in plain text
- **NEVER** use weak random number generators for security

### **SECRETS MANAGEMENT**

- **ALWAYS** use environment variables for secrets
- **ALWAYS** use proper secret management systems in production
- **NEVER** hardcode secrets, API keys, or passwords in code
- **NEVER** commit secrets to version control

## üîí SECURITY PATTERNS - ENFORCED

### **Safe Input Handling**

```python
import re
from typing import Optional

def validate_email(email: str) -> bool:
    """Validate email format using regex."""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))

def sanitize_filename(filename: str) -> str:
    """Sanitize filename to prevent path traversal."""
    # Remove dangerous characters
    safe_filename = re.sub(r'[^\w\-_\.]', '', filename)
    # Prevent path traversal
    safe_filename = safe_filename.replace('..', '')
    return safe_filename

# ‚úÖ CORRECT - Input validation
def process_user_input(user_input: str) -> Optional[str]:
    if not isinstance(user_input, str):
        raise ValueError("Input must be a string")

    if len(user_input) > 1000:
        raise ValueError("Input too long")

    # Sanitize and validate
    sanitized = sanitize_filename(user_input)
    return sanitized if sanitized else None
```

### **Secure Password Handling**

```python
import bcrypt
import secrets
from typing import Tuple

def hash_password(password: str) -> str:
    """Hash password using bcrypt."""
    if not isinstance(password, str):
        raise ValueError("Password must be a string")

    if len(password) < 8:
        raise ValueError("Password must be at least 8 characters")

    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def verify_password(password: str, hashed: str) -> bool:
    """Verify password against hash."""
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

def generate_secure_token() -> str:
    """Generate cryptographically secure token."""
    return secrets.token_urlsafe(32)
```

### **Safe Database Operations**

```python
import sqlite3
from typing import List, Dict, Any

def get_user_by_id(user_id: int) -> Optional[Dict[str, Any]]:
    """Safely retrieve user by ID using parameterized queries."""
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError("Invalid user ID")

    conn = sqlite3.connect('database.db')
    try:
        # ‚úÖ CORRECT - Parameterized query prevents SQL injection
        cursor = conn.execute(
            "SELECT * FROM users WHERE id = ?",
            (user_id,)
        )
        row = cursor.fetchone()
        return dict(zip([col[0] for col in cursor.description], row)) if row else None
    finally:
        conn.close()

# ‚ùå WRONG - SQL injection vulnerability
def get_user_by_id_unsafe(user_id: str) -> Dict[str, Any]:
    conn = sqlite3.connect('database.db')
    # NEVER DO THIS - SQL injection risk
    cursor = conn.execute(f"SELECT * FROM users WHERE id = {user_id}")
    return cursor.fetchone()
```

## üö´ CRITICAL SECURITY VIOLATIONS - NEVER ALLOW

### **ABSOLUTE PROHIBITIONS:**

- ‚ùå **NEVER** use `eval()` or `exec()` with user input
- ‚ùå **NEVER** use `pickle` with untrusted data
- ‚ùå **NEVER** use `subprocess` with `shell=True` and user input
- ‚ùå **NEVER** store secrets in code or configuration files
- ‚ùå **NEVER** use weak random number generators for security
- ‚ùå **NEVER** disable SSL/TLS certificate verification
- ‚ùå **NEVER** use hardcoded credentials or API keys

### **DANGEROUS PATTERNS:**

```python
# ‚ùå CRITICAL SECURITY VIOLATIONS - NEVER USE

# 1. Code injection
user_code = input("Enter code: ")
eval(user_code)  # NEVER DO THIS

# 2. Command injection
user_input = input("Enter filename: ")
os.system(f"cat {user_input}")  # NEVER DO THIS

# 3. Unsafe deserialization
import pickle
with open('data.pkl', 'rb') as f:
    data = pickle.load(f)  # NEVER DO THIS with untrusted data

# 4. Hardcoded secrets
API_KEY = "sk-1234567890abcdef"  # NEVER DO THIS
DATABASE_PASSWORD = "password123"  # NEVER DO THIS

# 5. Weak random for security
import random
token = str(random.randint(100000, 999999))  # NEVER DO THIS
```

## üîê SECURE CODING PATTERNS

### **Environment Variables for Secrets**

```python
import os
from typing import Optional

def get_secret(secret_name: str, default: Optional[str] = None) -> str:
    """Safely retrieve secret from environment variables."""
    secret = os.getenv(secret_name, default)
    if not secret:
        raise ValueError(f"Secret {secret_name} not found in environment")
    return secret

# ‚úÖ CORRECT - Use environment variables
DATABASE_URL = get_secret('DATABASE_URL')
API_KEY = get_secret('API_KEY')
JWT_SECRET = get_secret('JWT_SECRET')
```

### **Secure File Operations**

```python
import os
from pathlib import Path
from typing import Optional

def safe_file_read(file_path: str) -> Optional[str]:
    """Safely read file with path traversal protection."""
    path = Path(file_path)

    # Prevent path traversal
    if '..' in str(path) or path.is_absolute():
        raise ValueError("Invalid file path")

    # Check if file exists and is readable
    if not path.exists() or not path.is_file():
        raise FileNotFoundError("File not found")

    try:
        with open(path, 'r', encoding='utf-8') as f:
            return f.read()
    except UnicodeDecodeError:
        raise ValueError("File contains invalid characters")
```

### **Secure HTTP Requests**

```python
import requests
from typing import Dict, Any
import ssl

def secure_http_request(url: str, data: Dict[str, Any]) -> Dict[str, Any]:
    """Make secure HTTP request with proper validation."""
    # Validate URL
    if not url.startswith(('https://', 'http://')):
        raise ValueError("Invalid URL protocol")

    # Create session with secure settings
    session = requests.Session()
    session.verify = True  # Verify SSL certificates

    try:
        response = session.post(
            url,
            json=data,
            timeout=30,
            headers={'Content-Type': 'application/json'}
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.SSLError:
        raise ValueError("SSL certificate verification failed")
    except requests.exceptions.Timeout:
        raise ValueError("Request timeout")
```

## üõ°Ô∏è SECURITY TESTING REQUIREMENTS

### **Security Test Cases**

```python
import pytest
from unittest.mock import patch

class TestSecurityFeatures:
    """Test security-related functionality."""

    def test_sql_injection_prevention(self):
        """Test that SQL injection attempts are prevented."""
        malicious_input = "1; DROP TABLE users; --"

        with pytest.raises(ValueError):
            get_user_by_id(malicious_input)

    def test_path_traversal_prevention(self):
        """Test that path traversal attempts are blocked."""
        malicious_path = "../../../etc/passwd"

        with pytest.raises(ValueError):
            safe_file_read(malicious_path)

    def test_input_validation(self):
        """Test that invalid inputs are rejected."""
        invalid_inputs = [
            None,
            "",
            "x" * 10000,  # Too long
            "<script>alert('xss')</script>",  # XSS attempt
        ]

        for invalid_input in invalid_inputs:
            with pytest.raises((ValueError, TypeError)):
                validate_email(invalid_input)
```

## üìã SECURITY CHECKLIST

### **Before Every Deployment:**

- [ ] No hardcoded secrets or credentials
- [ ] All user inputs are validated and sanitized
- [ ] SQL queries use parameterized statements
- [ ] Passwords are properly hashed
- [ ] SSL/TLS is properly configured
- [ ] Error messages don't leak sensitive information
- [ ] File operations are protected against path traversal
- [ ] All external requests use HTTPS
- [ ] Session management is secure
- [ ] Logging doesn't include sensitive data

### **Security Headers (for web applications):**

```python
# Add these headers to all HTTP responses
SECURITY_HEADERS = {
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Content-Security-Policy': "default-src 'self'",
}
```

## üö® EMERGENCY SECURITY RESPONSE

### **If Security Issue is Discovered:**

1. **IMMEDIATELY** revoke compromised credentials
2. **IMMEDIATELY** patch the vulnerability
3. **IMMEDIATELY** rotate all secrets and keys
4. **IMMEDIATELY** audit logs for suspicious activity
5. **IMMEDIATELY** notify security team
6. **NEVER** ignore or delay security fixes
</file>

<file path=".cursor/rules/testing.mdc">
---
globs: test_*.py,*_test.py,conftest.py
description: Testing and documentation rules for Python development
---

# Python Testing & Documentation Rules

## üß™ CRITICAL TESTING REQUIREMENTS

### **TEST COVERAGE - MANDATORY**

- **ALWAYS** achieve >90% code coverage
- **ALWAYS** test all public functions and methods
- **ALWAYS** test both success and failure scenarios
- **ALWAYS** test edge cases and boundary conditions
- **NEVER** commit code without corresponding tests

### **TEST STRUCTURE - MANDATORY**

- **ALWAYS** use pytest as the testing framework
- **ALWAYS** organize tests in classes for related functionality
- **ALWAYS** use descriptive test method names
- **ALWAYS** follow AAA pattern (Arrange, Act, Assert)
- **NEVER** write tests that depend on external services

### **MOCKING - MANDATORY**

- **ALWAYS** mock external dependencies (APIs, databases, file system)
- **ALWAYS** use dependency injection for testability
- **ALWAYS** verify mock calls and arguments
- **NEVER** make real network calls in tests
- **NEVER** use real database connections in unit tests

## üìù DOCUMENTATION REQUIREMENTS

### **DOCSTRINGS - MANDATORY**

- **ALWAYS** write docstrings for all public functions, classes, and modules
- **ALWAYS** follow Google-style docstring format
- **ALWAYS** include parameter types, return types, and exceptions
- **ALWAYS** provide usage examples for complex functions
- **NEVER** leave public functions undocumented

### **CODE COMMENTS - MANDATORY**

- **ALWAYS** explain complex business logic
- **ALWAYS** document non-obvious performance optimizations
- **ALWAYS** explain why, not what
- **NEVER** comment obvious code
- **NEVER** leave TODO comments in production code

## üß™ TESTING PATTERNS - ENFORCED

### **Unit Test Structure**

```python
import pytest
from unittest.mock import Mock, patch, MagicMock
from typing import List, Dict, Any
import tempfile
import os

class TestUserService:
    """Test suite for UserService class."""

    def setup_method(self):
        """Set up test fixtures before each test method."""
        self.user_service = UserService()
        self.mock_user = Mock()
        self.mock_user.id = 1
        self.mock_user.name = "John Doe"
        self.mock_user.email = "john@example.com"

    def test_create_user_success(self):
        """Test successful user creation with valid data."""
        # Arrange
        user_data = {
            "name": "John Doe",
            "email": "john@example.com",
            "age": 30
        }
        expected_user = User(id=1, **user_data)

        with patch('app.services.user_service.UserRepository') as mock_repo:
            mock_repo.return_value.create.return_value = expected_user

            # Act
            result = self.user_service.create_user(user_data)

            # Assert
            assert result == expected_user
            mock_repo.return_value.create.assert_called_once_with(user_data)

    def test_create_user_invalid_email(self):
        """Test user creation fails with invalid email format."""
        # Arrange
        user_data = {
            "name": "John Doe",
            "email": "invalid-email-format",
            "age": 30
        }

        # Act & Assert
        with pytest.raises(ValidationError, match="Invalid email format"):
            self.user_service.create_user(user_data)

    def test_create_user_duplicate_email(self):
        """Test user creation fails when email already exists."""
        # Arrange
        user_data = {
            "name": "John Doe",
            "email": "existing@example.com",
            "age": 30
        }

        with patch('app.services.user_service.UserRepository') as mock_repo:
            mock_repo.return_value.find_by_email.return_value = self.mock_user

            # Act & Assert
            with pytest.raises(DuplicateEmailError):
                self.user_service.create_user(user_data)

    def test_get_user_by_id_success(self):
        """Test successful user retrieval by ID."""
        # Arrange
        user_id = 1

        with patch('app.services.user_service.UserRepository') as mock_repo:
            mock_repo.return_value.find_by_id.return_value = self.mock_user

            # Act
            result = self.user_service.get_user_by_id(user_id)

            # Assert
            assert result == self.mock_user
            mock_repo.return_value.find_by_id.assert_called_once_with(user_id)

    def test_get_user_by_id_not_found(self):
        """Test user retrieval returns None when user doesn't exist."""
        # Arrange
        user_id = 999

        with patch('app.services.user_service.UserRepository') as mock_repo:
            mock_repo.return_value.find_by_id.return_value = None

            # Act
            result = self.user_service.get_user_by_id(user_id)

            # Assert
            assert result is None
```

### **Integration Test Structure**

```python
import pytest
import asyncio
from httpx import AsyncClient
from app.main import app
from app.database import get_test_db

class TestUserAPI:
    """Integration tests for User API endpoints."""

    @pytest.fixture
    async def client(self):
        """Create test client with test database."""
        async with AsyncClient(app=app, base_url="http://test") as ac:
            yield ac

    @pytest.fixture
    async def test_user(self, client):
        """Create a test user for API tests."""
        user_data = {
            "name": "Test User",
            "email": "test@example.com",
            "age": 25
        }
        response = await client.post("/users", json=user_data)
        return response.json()

    async def test_create_user_endpoint(self, client):
        """Test POST /users endpoint."""
        # Arrange
        user_data = {
            "name": "New User",
            "email": "newuser@example.com",
            "age": 30
        }

        # Act
        response = await client.post("/users", json=user_data)

        # Assert
        assert response.status_code == 201
        data = response.json()
        assert data["name"] == user_data["name"]
        assert data["email"] == user_data["email"]
        assert "id" in data

    async def test_get_user_endpoint(self, client, test_user):
        """Test GET /users/{user_id} endpoint."""
        # Act
        response = await client.get(f"/users/{test_user['id']}")

        # Assert
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == test_user["id"]
        assert data["name"] == test_user["name"]

    async def test_get_user_not_found(self, client):
        """Test GET /users/{user_id} returns 404 for non-existent user."""
        # Act
        response = await client.get("/users/999")

        # Assert
        assert response.status_code == 404
```

### **Fixture Management**

```python
import pytest
from typing import Generator, AsyncGenerator
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.database import Base, get_db
from app.models import User

@pytest.fixture(scope="session")
def test_engine():
    """Create test database engine."""
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    return engine

@pytest.fixture
def test_db(test_engine):
    """Create test database session."""
    TestingSessionLocal = sessionmaker(bind=test_engine)
    session = TestingSessionLocal()
    try:
        yield session
    finally:
        session.close()

@pytest.fixture
def sample_user(test_db) -> User:
    """Create a sample user for testing."""
    user = User(
        name="Test User",
        email="test@example.com",
        age=25
    )
    test_db.add(user)
    test_db.commit()
    test_db.refresh(user)
    return user

@pytest.fixture
def multiple_users(test_db) -> List[User]:
    """Create multiple users for testing."""
    users = [
        User(name=f"User {i}", email=f"user{i}@example.com", age=20+i)
        for i in range(5)
    ]
    test_db.add_all(users)
    test_db.commit()
    return users
```

## üìö DOCUMENTATION PATTERNS

### **Function Documentation**

```python
def calculate_compound_interest(
    principal: float,
    rate: float,
    time: int,
    compounding_frequency: int = 12
) -> float:
    """
    Calculate compound interest for an investment.

    This function calculates the compound interest using the formula:
    A = P(1 + r/n)^(nt)
    where:
    - A = final amount
    - P = principal amount
    - r = annual interest rate
    - n = number of times interest is compounded per year
    - t = time in years

    Args:
        principal: The initial amount of money invested
        rate: Annual interest rate as a decimal (e.g., 0.05 for 5%)
        time: Time period in years
        compounding_frequency: Number of times interest is compounded per year

    Returns:
        The final amount after compound interest

    Raises:
        ValueError: If principal, rate, or time is negative
        ZeroDivisionError: If compounding_frequency is zero

    Example:
        >>> calculate_compound_interest(1000, 0.05, 2, 12)
        1104.94

    Note:
        The result is rounded to 2 decimal places for currency display.
    """
    if principal < 0 or rate < 0 or time < 0:
        raise ValueError("Principal, rate, and time must be non-negative")

    if compounding_frequency <= 0:
        raise ZeroDivisionError("Compounding frequency must be positive")

    amount = principal * (1 + rate / compounding_frequency) ** (compounding_frequency * time)
    return round(amount, 2)
```

### **Class Documentation**

```python
class DataProcessor:
    """
    A class for processing and analyzing data with various statistical methods.

    This class provides methods for data cleaning, transformation, and analysis.
    It supports both numerical and categorical data processing.

    Attributes:
        data: The dataset being processed
        cleaned_data: The cleaned version of the data
        statistics: Dictionary containing calculated statistics

    Example:
        >>> processor = DataProcessor([1, 2, 3, 4, 5])
        >>> processor.calculate_mean()
        3.0
        >>> processor.remove_outliers()
        >>> processor.get_statistics()
        {'mean': 3.0, 'std': 1.58, 'count': 5}
    """

    def __init__(self, data: List[Union[int, float]]) -> None:
        """
        Initialize the DataProcessor with a dataset.

        Args:
            data: List of numerical values to process

        Raises:
            TypeError: If data contains non-numerical values
            ValueError: If data is empty
        """
        if not data:
            raise ValueError("Data cannot be empty")

        if not all(isinstance(x, (int, float)) for x in data):
            raise TypeError("All data values must be numerical")

        self.data = data
        self.cleaned_data = data.copy()
        self.statistics = {}

    def calculate_mean(self) -> float:
        """
        Calculate the arithmetic mean of the data.

        Returns:
            The mean value of the dataset

        Example:
            >>> processor = DataProcessor([1, 2, 3, 4, 5])
            >>> processor.calculate_mean()
            3.0
        """
        return sum(self.cleaned_data) / len(self.cleaned_data)
```

## üö´ TESTING ANTI-PATTERNS

### **NEVER DO THESE IN TESTS:**

- ‚ùå Make real network calls
- ‚ùå Use real database connections
- ‚ùå Write tests that depend on external services
- ‚ùå Write tests that depend on file system state
- ‚ùå Use hardcoded test data without fixtures
- ‚ùå Write tests without proper assertions
- ‚ùå Skip error handling in tests
- ‚ùå Write tests that are too complex

### **COMMON TESTING MISTAKES:**

```python
# ‚ùå WRONG - Test with real network call
def test_fetch_data_wrong():
    response = requests.get('https://api.example.com/data')
    assert response.status_code == 200

# ‚úÖ CORRECT - Mock the network call
@patch('requests.get')
def test_fetch_data_correct(mock_get):
    mock_get.return_value.status_code = 200
    mock_get.return_value.json.return_value = {'data': 'test'}

    result = fetch_data()
    assert result == {'data': 'test'}
    mock_get.assert_called_once_with('https://api.example.com/data')

# ‚ùå WRONG - Test without proper setup/teardown
def test_database_operation_wrong():
    # This test will fail if run multiple times
    user = create_user("test@example.com")
    assert user.email == "test@example.com"

# ‚úÖ CORRECT - Use fixtures for setup/teardown
@pytest.fixture
def clean_database():
    # Setup
    yield
    # Teardown - clean up after test
    clear_all_tables()
```

## üìã TESTING CHECKLIST

### **Before Every Commit:**

- [ ] All new functions have unit tests
- [ ] All edge cases are tested
- [ ] All error conditions are tested
- [ ] All external dependencies are mocked
- [ ] Test coverage is >90%
- [ ] All tests pass
- [ ] No flaky tests
- [ ] Tests are fast (<1 second each)
- [ ] Tests are independent
- [ ] All public functions are documented

### **Test Quality Checklist:**

- [ ] Test names clearly describe what is being tested
- [ ] Tests follow AAA pattern (Arrange, Act, Assert)
- [ ] Tests are isolated and can run in any order
- [ ] Tests use appropriate fixtures
- [ ] Tests verify both success and failure scenarios
- [ ] Tests are maintainable and readable
- [ ] Tests don't have side effects
- [ ] Tests are deterministic (same result every time)
</file>

<file path="01_asyncio_basics.py">
"""
asyncio Í∏∞Ï¥à ÏòàÏ†ú
ÎπÑÎèôÍ∏∞ ÌîÑÎ°úÍ∑∏ÎûòÎ∞çÏùò Í∏∞Î≥∏ Í∞úÎÖêÏùÑ ÌïôÏäµÌï©ÎãàÎã§.
"""

import asyncio
import time
from typing import List


async def simple_task(name: str, delay: float) -> str:
    """
    Í∞ÑÎã®Ìïú ÎπÑÎèôÍ∏∞ ÏûëÏóÖÏùÑ ÏàòÌñâÌï©ÎãàÎã§.

    Args:
        name: ÏûëÏóÖ Ïù¥Î¶Ñ
        delay: ÎåÄÍ∏∞ ÏãúÍ∞Ñ (Ï¥à)

    Returns:
        ÏôÑÎ£å Î©îÏãúÏßÄ
    """
    print(f"ÏûëÏóÖ {name} ÏãúÏûë")
    await asyncio.sleep(delay)  # ÎπÑÎèôÍ∏∞ ÎåÄÍ∏∞
    print(f"ÏûëÏóÖ {name} ÏôÑÎ£å")
    return f"{name} ÏûëÏóÖÏù¥ {delay}Ï¥à ÌõÑ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§"


async def fetch_data(url: str, delay: float) -> dict:
    """
    Í∞ÄÏÉÅÏùò Îç∞Ïù¥ÌÑ∞ ÌéòÏπ≠ ÏûëÏóÖÏùÑ ÏãúÎÆ¨Î†àÏù¥ÏÖòÌï©ÎãàÎã§.

    Args:
        url: Í∞ÄÏÉÅÏùò URL
        delay: ÎÑ§Ìä∏ÏõåÌÅ¨ ÏßÄÏó∞ ÏãúÎÆ¨Î†àÏù¥ÏÖò

    Returns:
        Í∞ÄÏÉÅÏùò Îç∞Ïù¥ÌÑ∞
    """
    print(f"Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠: {url}")
    await asyncio.sleep(delay)
    return {
        "url": url,
        "data": f"URL {url}ÏóêÏÑú Í∞ÄÏ†∏Ïò® Îç∞Ïù¥ÌÑ∞",
        "timestamp": time.time(),
    }


def sync_task(name: str, delay: float) -> str:
    """
    ÎèôÍ∏∞ Î≤ÑÏ†ÑÏùò ÏûëÏóÖ Ìï®Ïàò (ÎπÑÍµêÏö©)

    Args:
        name: ÏûëÏóÖ Ïù¥Î¶Ñ
        delay: ÎåÄÍ∏∞ ÏãúÍ∞Ñ (Ï¥à)

    Returns:
        ÏôÑÎ£å Î©îÏãúÏßÄ
    """
    print(f"ÎèôÍ∏∞ ÏûëÏóÖ {name} ÏãúÏûë")
    time.sleep(delay)  # ÎèôÍ∏∞ ÎåÄÍ∏∞ (Î∏îÎ°úÌÇπ)
    print(f"ÎèôÍ∏∞ ÏûëÏóÖ {name} ÏôÑÎ£å")
    return f"{name} ÏûëÏóÖÏù¥ {delay}Ï¥à ÌõÑ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§"


async def demo_sleep_difference():
    """time.sleep vs asyncio.sleep Ï∞®Ïù¥Ï†ê Îç∞Î™®"""
    print("=== time.sleep vs asyncio.sleep Ï∞®Ïù¥Ï†ê ===")

    async def async_task_with_sync_sleep(name: str, delay: float) -> str:
        """ÎπÑÎèôÍ∏∞ Ìï®ÏàòÏóêÏÑú time.sleep ÏÇ¨Ïö© (ÏûòÎ™ªÎêú Î∞©Î≤ï)"""
        print(f"ÏûëÏóÖ {name} ÏãúÏûë (time.sleep ÏÇ¨Ïö©)")
        time.sleep(delay)  # ‚ùå Ïù¥Î†áÍ≤å ÌïòÎ©¥ ÏïàÎê®!
        print(f"ÏûëÏóÖ {name} ÏôÑÎ£å")
        return f"{name} ÏôÑÎ£å"

    async def async_task_with_async_sleep(name: str, delay: float) -> str:
        """ÎπÑÎèôÍ∏∞ Ìï®ÏàòÏóêÏÑú asyncio.sleep ÏÇ¨Ïö© (Ïò¨Î∞îÎ•∏ Î∞©Î≤ï)"""
        print(f"ÏûëÏóÖ {name} ÏãúÏûë (asyncio.sleep ÏÇ¨Ïö©)")
        await asyncio.sleep(delay)  # ‚úÖ Ïò¨Î∞îÎ•∏ Î∞©Î≤ï
        print(f"ÏûëÏóÖ {name} ÏôÑÎ£å")
        return f"{name} ÏôÑÎ£å"

    # 1. time.sleepÏùÑ ÏÇ¨Ïö©Ìïú ÏûòÎ™ªÎêú ÎπÑÎèôÍ∏∞ ÏΩîÎìú
    print("\n--- time.sleep ÏÇ¨Ïö© (ÏûòÎ™ªÎêú Î∞©Î≤ï) ---")
    start_time = time.time()
    results1 = await asyncio.gather(
        async_task_with_sync_sleep("A", 1.0),
        async_task_with_sync_sleep("B", 1.0),
        async_task_with_sync_sleep("C", 1.0),
    )
    end_time = time.time()
    print(f"time.sleep ÏÇ¨Ïö© ÏãúÍ∞Ñ: {end_time - start_time:.2f}Ï¥à")
    print("‚ùå time.sleepÏùÄ Î∏îÎ°úÌÇπÏù¥ÎØÄÎ°ú ÎèôÏãú Ïã§ÌñâÏù¥ ÏïàÎê®!")

    # 2. asyncio.sleepÏùÑ ÏÇ¨Ïö©Ìïú Ïò¨Î∞îÎ•∏ ÎπÑÎèôÍ∏∞ ÏΩîÎìú
    print("\n--- asyncio.sleep ÏÇ¨Ïö© (Ïò¨Î∞îÎ•∏ Î∞©Î≤ï) ---")
    start_time = time.time()
    results2 = await asyncio.gather(
        async_task_with_async_sleep("D", 1.0),
        async_task_with_async_sleep("E", 1.0),
        async_task_with_async_sleep("F", 1.0),
    )
    end_time = time.time()
    print(f"asyncio.sleep ÏÇ¨Ïö© ÏãúÍ∞Ñ: {end_time - start_time:.2f}Ï¥à")
    print("‚úÖ asyncio.sleepÏùÄ ÎÖºÎ∏îÎ°úÌÇπÏù¥ÎØÄÎ°ú ÎèôÏãú Ïã§ÌñâÎê®!")


async def main_basic():
    """Í∏∞Î≥∏Ï†ÅÏù∏ asyncio ÏÇ¨Ïö©Î≤ï"""
    print("=== asyncio Í∏∞Î≥∏ ÏòàÏ†ú ===")

    # 1. Îã®Ïùº ÏΩîÎ£®Ìã¥ Ïã§Ìñâ
    result = await simple_task("A", 1.0)
    print(f"Í≤∞Í≥º: {result}")

    # 2. sleep Ï∞®Ïù¥Ï†ê Îç∞Î™®
    await demo_sleep_difference()

    # 3. ÎèôÍ∏∞ Ìï®ÏàòÎ°ú ÏàúÏ∞® Ïã§Ìñâ (ÎäêÎ¶º)
    print("\n--- ÎèôÍ∏∞ Ìï®Ïàò ÏàúÏ∞® Ïã§Ìñâ ---")
    start_time = time.time()
    result1 = sync_task("B", 1.0)
    result2 = sync_task("C", 1.0)
    end_time = time.time()
    print(f"ÎèôÍ∏∞ ÏàúÏ∞® Ïã§Ìñâ ÏãúÍ∞Ñ: {end_time - start_time:.2f}Ï¥à")

    # 4. ÎπÑÎèôÍ∏∞ Ìï®ÏàòÎ°ú ÏàúÏ∞® Ïã§Ìñâ (Ïó¨Ï†ÑÌûà ÎäêÎ¶º)
    print("\n--- ÎπÑÎèôÍ∏∞ Ìï®Ïàò ÏàúÏ∞® Ïã§Ìñâ ---")
    start_time = time.time()
    result1 = await simple_task("D", 1.0)
    result2 = await simple_task("E", 1.0)
    end_time = time.time()
    print(f"ÎπÑÎèôÍ∏∞ ÏàúÏ∞® Ïã§Ìñâ ÏãúÍ∞Ñ: {end_time - start_time:.2f}Ï¥à")
    print("üí° ÏàúÏ∞® Ïã§ÌñâÏùÄ ÎèôÍ∏∞/ÎπÑÎèôÍ∏∞ Ï∞®Ïù¥Í∞Ä ÏóÜÏäµÎãàÎã§!")


async def main_concurrent():
    """ÎèôÏãú Ïã§Ìñâ ÏòàÏ†ú"""
    print("\n=== ÎèôÏãú Ïã§Ìñâ ÏòàÏ†ú ===")

    # 1. ÎèôÍ∏∞ Ìï®ÏàòÎ°ú ÏàúÏ∞® Ïã§Ìñâ (ÎäêÎ¶º)
    print("--- ÎèôÍ∏∞ Ìï®Ïàò ÏàúÏ∞® Ïã§Ìñâ ---")
    start_time = time.time()
    result1 = sync_task("G", 1.0)
    result2 = sync_task("H", 1.0)
    result3 = sync_task("I", 1.0)
    end_time = time.time()
    sync_time = end_time - start_time
    print(f"ÎèôÍ∏∞ ÏàúÏ∞® Ïã§Ìñâ ÏãúÍ∞Ñ: {sync_time:.2f}Ï¥à")

    # 2. ÎπÑÎèôÍ∏∞ Ìï®ÏàòÎ°ú ÎèôÏãú Ïã§Ìñâ (Îπ†Î¶Ñ)
    print("\n--- ÎπÑÎèôÍ∏∞ Ìï®Ïàò ÎèôÏãú Ïã§Ìñâ ---")
    start_time = time.time()
    results = await asyncio.gather(
        simple_task("J", 1.0), simple_task("K", 1.0), simple_task("L", 1.0)
    )
    end_time = time.time()
    async_time = end_time - start_time
    print(f"ÎπÑÎèôÍ∏∞ ÎèôÏãú Ïã§Ìñâ ÏãúÍ∞Ñ: {async_time:.2f}Ï¥à")
    print(f"Í≤∞Í≥ºÎì§: {results}")

    # 3. ÏÑ±Îä• ÎπÑÍµê
    speedup = sync_time / async_time if async_time > 0 else 0
    print(f"\nüöÄ ÎπÑÎèôÍ∏∞ ÎèôÏãú Ïã§ÌñâÏù¥ {speedup:.1f}Î∞∞ Îπ†Î¶ÖÎãàÎã§!")
    print(f"   ÏãúÍ∞Ñ Ï†àÏïΩ: {sync_time - async_time:.2f}Ï¥à")


async def main_data_fetching():
    """Îç∞Ïù¥ÌÑ∞ ÌéòÏπ≠ ÏãúÎÆ¨Î†àÏù¥ÏÖò"""
    print("\n=== Îç∞Ïù¥ÌÑ∞ ÌéòÏπ≠ ÏãúÎÆ¨Î†àÏù¥ÏÖò ===")

    urls = [
        "https://api.example.com/users",
        "https://api.example.com/posts",
        "https://api.example.com/comments",
    ]

    # ÎèôÏãúÏóê Ïó¨Îü¨ API Ìò∏Ï∂ú
    start_time = time.time()
    tasks = [fetch_data(url, 1.0) for url in urls]
    results = await asyncio.gather(*tasks)
    end_time = time.time()

    print(f"Î™®Îì† Îç∞Ïù¥ÌÑ∞ ÌéòÏπ≠ ÏôÑÎ£å: {end_time - start_time:.2f}Ï¥à")
    for result in results:
        print(f"  - {result['url']}: {result['data']}")


async def main_with_tasks():
    """Task Í∞ùÏ≤¥Î•º ÏÇ¨Ïö©Ìïú ÏòàÏ†ú"""
    print("\n=== Task Í∞ùÏ≤¥ ÏÇ¨Ïö© ÏòàÏ†ú ===")

    # Task ÏÉùÏÑ±
    task1 = asyncio.create_task(simple_task("Task1", 2.0))
    task2 = asyncio.create_task(simple_task("Task2", 1.0))
    task3 = asyncio.create_task(simple_task("Task3", 1.5))

    # Î™®Îì† ÏûëÏóÖ ÏôÑÎ£å ÎåÄÍ∏∞
    results = await asyncio.gather(task1, task2, task3)
    print(f"Task Í≤∞Í≥ºÎì§: {results}")


async def main_with_timeout():
    """ÌÉÄÏûÑÏïÑÏõÉ Ï≤òÎ¶¨ ÏòàÏ†ú"""
    print("\n=== ÌÉÄÏûÑÏïÑÏõÉ Ï≤òÎ¶¨ ÏòàÏ†ú ===")

    try:
        # 2Ï¥à ÌÉÄÏûÑÏïÑÏõÉÏúºÎ°ú 3Ï¥à ÏûëÏóÖ Ïã§Ìñâ
        result = await asyncio.wait_for(simple_task("Timeout", 3.0), timeout=2.0)
        print(f"Í≤∞Í≥º: {result}")
    except asyncio.TimeoutError:
        print("ÏûëÏóÖÏù¥ ÌÉÄÏûÑÏïÑÏõÉÎêòÏóàÏäµÎãàÎã§!")


async def main_with_cancellation():
    """ÏûëÏóÖ Ï∑®ÏÜå ÏòàÏ†ú"""
    print("\n=== ÏûëÏóÖ Ï∑®ÏÜå ÏòàÏ†ú ===")

    async def long_running_task():
        try:
            for i in range(10):
                print(f"Í∏¥ ÏûëÏóÖ ÏßÑÌñâ Ï§ë... {i+1}/10")
                await asyncio.sleep(0.5)
            return "Í∏¥ ÏûëÏóÖ ÏôÑÎ£å"
        except asyncio.CancelledError:
            print("ÏûëÏóÖÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§!")
            raise

    # 2Ï¥à ÌõÑ ÏûëÏóÖ Ï∑®ÏÜå
    task = asyncio.create_task(long_running_task())
    await asyncio.sleep(2.0)
    task.cancel()

    try:
        result = await task
        print(f"Í≤∞Í≥º: {result}")
    except asyncio.CancelledError:
        print("ÏûëÏóÖÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§")


if __name__ == "__main__":
    print("asyncio Í∏∞Ï¥à ÌïôÏäµÏùÑ ÏãúÏûëÌï©ÎãàÎã§...\n")

    # Î™®Îì† ÏòàÏ†ú Ïã§Ìñâ
    asyncio.run(main_basic())
    asyncio.run(main_concurrent())
    asyncio.run(main_data_fetching())
    asyncio.run(main_with_tasks())
    asyncio.run(main_with_timeout())
    asyncio.run(main_with_cancellation())

    print("\nasyncio Í∏∞Ï¥à ÌïôÏäµÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!")
</file>

<file path="02_websocket_basics.py">
"""
ÏõπÏÜåÏºì Í∏∞Ï¥à ÏòàÏ†ú
ÏõπÏÜåÏºì ÏÑúÎ≤ÑÏôÄ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò Í∏∞Î≥∏ ÏÇ¨Ïö©Î≤ïÏùÑ ÌïôÏäµÌï©ÎãàÎã§.
"""

import asyncio
import json
import logging
from typing import Dict, Set, Optional
from datetime import datetime

import websockets
from websockets.server import WebSocketServerProtocol
from websockets.exceptions import ConnectionClosed

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class WebSocketServer:
    """ÏõπÏÜåÏºì ÏÑúÎ≤Ñ ÌÅ¥ÎûòÏä§"""

    def __init__(self, host: str = "localhost", port: int = 8765):
        self.host = host
        self.port = port
        self.clients: Set[WebSocketServerProtocol] = set()
        self.message_count = 0

    async def register_client(self, websocket: WebSocketServerProtocol) -> None:
        """ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù"""
        self.clients.add(websocket)
        logger.info(f"ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞: {websocket.remote_address}")
        logger.info(f"ÌòÑÏû¨ Ïó∞Í≤∞Îêú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïàò: {len(self.clients)}")

    async def unregister_client(self, websocket: WebSocketServerProtocol) -> None:
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ìï¥Ï†ú"""
        self.clients.discard(websocket)
        logger.info(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ìï¥Ï†ú: {websocket.remote_address}")
        logger.info(f"ÌòÑÏû¨ Ïó∞Í≤∞Îêú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïàò: {len(self.clients)}")

    async def broadcast_message(
        self, message: str, sender: Optional[WebSocketServerProtocol] = None
    ) -> None:
        """Î™®Îì† ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å Î©îÏãúÏßÄ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏"""
        if not self.clients:
            return

        # Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†úÍ±∞
        disconnected_clients = set()

        for client in self.clients.copy():
            try:
                await client.send(message)
            except ConnectionClosed:
                disconnected_clients.add(client)

        # ÎÅäÏñ¥ÏßÑ Ïó∞Í≤∞ Ï†úÍ±∞
        for client in disconnected_clients:
            await self.unregister_client(client)

    async def handle_client(self, websocket: WebSocketServerProtocol) -> None:
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï≤òÎ¶¨"""
        await self.register_client(websocket)

        try:
            async for message in websocket:
                await self.process_message(websocket, message)
        except ConnectionClosed:
            logger.info("ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞Ïù¥ Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§")
        except Exception as e:
            logger.error(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}")
        finally:
            await self.unregister_client(websocket)

    async def process_message(
        self, websocket: WebSocketServerProtocol, message: str
    ) -> None:
        """Î©îÏãúÏßÄ Ï≤òÎ¶¨"""
        self.message_count += 1

        try:
            # JSON Î©îÏãúÏßÄ ÌååÏã± ÏãúÎèÑ
            data = json.loads(message)
            message_type = data.get("type", "unknown")

            if message_type == "echo":
                # ÏóêÏΩî Î©îÏãúÏßÄ
                response = {
                    "type": "echo_response",
                    "original_message": data.get("message", ""),
                    "timestamp": datetime.now().isoformat(),
                    "server_message_count": self.message_count,
                }
                await websocket.send(json.dumps(response))

            elif message_type == "broadcast":
                # Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Î©îÏãúÏßÄ
                broadcast_data = {
                    "type": "broadcast",
                    "message": data.get("message", ""),
                    "sender": str(websocket.remote_address),
                    "timestamp": datetime.now().isoformat(),
                }
                await self.broadcast_message(json.dumps(broadcast_data), websocket)

            elif message_type == "ping":
                # Ìïë Î©îÏãúÏßÄ
                pong_response = {
                    "type": "pong",
                    "timestamp": datetime.now().isoformat(),
                }
                await websocket.send(json.dumps(pong_response))

            else:
                # Ïïå Ïàò ÏóÜÎäî Î©îÏãúÏßÄ ÌÉÄÏûÖ
                error_response = {
                    "type": "error",
                    "message": f"Ïïå Ïàò ÏóÜÎäî Î©îÏãúÏßÄ ÌÉÄÏûÖ: {message_type}",
                    "timestamp": datetime.now().isoformat(),
                }
                await websocket.send(json.dumps(error_response))

        except json.JSONDecodeError:
            # JSONÏù¥ ÏïÑÎãå ÏùºÎ∞ò ÌÖçÏä§Ìä∏ Î©îÏãúÏßÄ
            response = (
                f"ÏÑúÎ≤ÑÍ∞Ä Î∞õÏùÄ Î©îÏãúÏßÄ: {message} (Î©îÏãúÏßÄ Î≤àÌò∏: {self.message_count})"
            )
            await websocket.send(response)

    async def start_server(self) -> None:
        """ÏÑúÎ≤Ñ ÏãúÏûë"""
        logger.info(f"ÏõπÏÜåÏºì ÏÑúÎ≤Ñ ÏãúÏûë: ws://{self.host}:{self.port}")

        async def handler(websocket):
            await self.handle_client(websocket)

        async with websockets.serve(
            handler,
            self.host,
            self.port,
            ping_interval=20,  # 20Ï¥àÎßàÎã§ Ìïë Ï†ÑÏÜ°
            ping_timeout=10,  # 10Ï¥à ÎÇ¥ Ìïë ÏùëÎãµ ÏóÜÏúºÎ©¥ Ïó∞Í≤∞ Ï¢ÖÎ£å
            close_timeout=10,  # Ïó∞Í≤∞ Ï¢ÖÎ£å ÌÉÄÏûÑÏïÑÏõÉ
        ):
            logger.info("ÏÑúÎ≤ÑÍ∞Ä Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§. Ctrl+CÎ°ú Ï¢ÖÎ£åÌïòÏÑ∏Ïöî.")
            await asyncio.Future()  # ÏÑúÎ≤ÑÎ•º Í≥ÑÏÜç Ïã§Ìñâ


class WebSocketClient:
    """ÏõπÏÜåÏºì ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌÅ¥ÎûòÏä§"""

    def __init__(self, uri: str):
        self.uri = uri
        self.websocket: Optional[websockets.WebSocketServerProtocol] = None

    async def connect(self) -> None:
        """ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞"""
        try:
            self.websocket = await websockets.connect(self.uri)
            logger.info(f"ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞Îê®: {self.uri}")
        except Exception as e:
            logger.error(f"ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå®: {e}")
            raise

    async def disconnect(self) -> None:
        """ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ìï¥Ï†ú"""
        if self.websocket:
            await self.websocket.close()
            logger.info("ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ìï¥Ï†ú")

    async def send_message(self, message: str) -> None:
        """Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        if not self.websocket:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        await self.websocket.send(message)
        logger.info(f"Î©îÏãúÏßÄ Ï†ÑÏÜ°: {message}")

    async def send_json(self, data: dict) -> None:
        """JSON Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        message = json.dumps(data)
        await self.send_message(message)

    async def receive_message(self) -> str:
        """Î©îÏãúÏßÄ ÏàòÏã†"""
        if not self.websocket:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        message = await self.websocket.recv()
        logger.info(f"Î©îÏãúÏßÄ ÏàòÏã†: {message}")
        return message

    async def listen_for_messages(self) -> None:
        """Î©îÏãúÏßÄ ÏàòÏã† ÎåÄÍ∏∞"""
        if not self.websocket:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        try:
            async for message in self.websocket:
                logger.info(f"ÏàòÏã†Îêú Î©îÏãúÏßÄ: {message}")
        except ConnectionClosed:
            logger.info("ÏÑúÎ≤Ñ Ïó∞Í≤∞Ïù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§")
        except Exception as e:
            logger.error(f"Î©îÏãúÏßÄ ÏàòÏã† Ï§ë Ïò§Î•ò: {e}")


async def demo_client_interactions():
    """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉÅÌò∏ÏûëÏö© Îç∞Î™®"""
    client = WebSocketClient("ws://localhost:8765")

    try:
        await client.connect()

        # 1. ÏùºÎ∞ò ÌÖçÏä§Ìä∏ Î©îÏãúÏßÄ Ï†ÑÏÜ°
        await client.send_message("ÏïàÎÖïÌïòÏÑ∏Ïöî, ÏÑúÎ≤Ñ!")

        # 2. JSON Î©îÏãúÏßÄ Ï†ÑÏÜ° (ÏóêÏΩî)
        echo_data = {"type": "echo", "message": "Ïù¥ Î©îÏãúÏßÄÎ•º ÏóêÏΩîÌï¥Ï£ºÏÑ∏Ïöî"}
        await client.send_json(echo_data)

        # 3. Ìïë Î©îÏãúÏßÄ Ï†ÑÏÜ°
        ping_data = {"type": "ping"}
        await client.send_json(ping_data)

        # 4. Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Î©îÏãúÏßÄ Ï†ÑÏÜ°
        broadcast_data = {
            "type": "broadcast",
            "message": "Î™®Îì† ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å Ï†ÑÏÜ°ÎêòÎäî Î©îÏãúÏßÄÏûÖÎãàÎã§",
        }
        await client.send_json(broadcast_data)

        # ÏùëÎãµ ÏàòÏã†
        for _ in range(4):
            try:
                response = await asyncio.wait_for(client.receive_message(), timeout=2.0)
                print(f"ÏÑúÎ≤Ñ ÏùëÎãµ: {response}")
            except asyncio.TimeoutError:
                print("ÏùëÎãµ ÌÉÄÏûÑÏïÑÏõÉ")
                break

    except Exception as e:
        logger.error(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îç∞Î™® Ïò§Î•ò: {e}")
    finally:
        await client.disconnect()


async def demo_multiple_clients():
    """Ïó¨Îü¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îç∞Î™®"""
    clients = []

    try:
        # 3Í∞úÏùò ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
        for i in range(3):
            client = WebSocketClient(f"ws://localhost:8765")
            await client.connect()
            clients.append(client)

            # Í∞Å ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Î©îÏãúÏßÄ Ï†ÑÏÜ°
            broadcast_data = {
                "type": "broadcast",
                "message": f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ {i+1}ÏóêÏÑú Ï†ÑÏÜ°Ìïú Î©îÏãúÏßÄ",
            }
            await client.send_json(broadcast_data)

            # Ïû†Ïãú ÎåÄÍ∏∞
            await asyncio.sleep(0.5)

        # Î™®Îì† ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò ÏùëÎãµ ÏàòÏã†
        for client in clients:
            try:
                response = await asyncio.wait_for(client.receive_message(), timeout=1.0)
                print(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏùëÎãµ: {response}")
            except asyncio.TimeoutError:
                print("ÏùëÎãµ ÌÉÄÏûÑÏïÑÏõÉ")

    finally:
        # Î™®Îì† ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ìï¥Ï†ú
        for client in clients:
            await client.disconnect()


async def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    print("ÏõπÏÜåÏºì Í∏∞Ï¥à ÌïôÏäµÏùÑ ÏãúÏûëÌï©ÎãàÎã§...\n")

    # ÏÑúÎ≤Ñ ÏãúÏûë (Î∞±Í∑∏ÎùºÏö¥Îìú)
    server = WebSocketServer()
    server_task = asyncio.create_task(server.start_server())

    # ÏÑúÎ≤Ñ ÏãúÏûë ÎåÄÍ∏∞
    await asyncio.sleep(1)

    print("=== Îã®Ïùº ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îç∞Î™® ===")
    await demo_client_interactions()

    print("\n=== Ïó¨Îü¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îç∞Î™® ===")
    await demo_multiple_clients()

    # ÏÑúÎ≤Ñ Ï¢ÖÎ£å
    server_task.cancel()
    try:
        await server_task
    except asyncio.CancelledError:
        pass

    print("\nÏõπÏÜåÏºì Í∏∞Ï¥à ÌïôÏäµÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="03_realtime_chat.py">
"""
Ïã§ÏãúÍ∞Ñ Ï±ÑÌåÖ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò
asyncioÏôÄ ÏõπÏÜåÏºìÏùÑ Í≤∞Ìï©Ìïú Ïã§Ï†Ñ ÏòàÏ†ú
"""

import asyncio
import json
import logging
import uuid
from datetime import datetime
from typing import Dict, Set, Optional, List
from dataclasses import dataclass, asdict
from enum import Enum

try:
    import websockets
    from websockets.server import WebSocketServerProtocol
    from websockets.exceptions import ConnectionClosed
except ImportError:
    print("websockets ÎùºÏù¥Î∏åÎü¨Î¶¨Í∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
    print("Îã§Ïùå Î™ÖÎ†πÏñ¥Î°ú ÏÑ§ÏπòÌïòÏÑ∏Ïöî: pip install websockets")
    exit(1)

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MessageType(Enum):
    """Î©îÏãúÏßÄ ÌÉÄÏûÖ Ïó¥Í±∞Ìòï"""

    JOIN = "join"
    LEAVE = "leave"
    MESSAGE = "message"
    USER_LIST = "user_list"
    ERROR = "error"
    HEARTBEAT = "heartbeat"


@dataclass
class User:
    """ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥"""

    id: str
    username: str
    websocket: WebSocketServerProtocol
    joined_at: datetime
    last_activity: datetime

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "username": self.username,
            "joined_at": self.joined_at.isoformat(),
            "last_activity": self.last_activity.isoformat(),
        }


@dataclass
class ChatMessage:
    """Ï±ÑÌåÖ Î©îÏãúÏßÄ"""

    id: str
    user_id: str
    username: str
    message: str
    timestamp: datetime
    message_type: MessageType = MessageType.MESSAGE

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "user_id": self.user_id,
            "username": self.username,
            "message": self.message,
            "timestamp": self.timestamp.isoformat(),
            "type": self.message_type.value,
        }


class ChatRoom:
    """Ï±ÑÌåÖÎ∞© Í¥ÄÎ¶¨ ÌÅ¥ÎûòÏä§"""

    def __init__(self, room_id: str = "general"):
        self.room_id = room_id
        self.users: Dict[str, User] = {}
        self.message_history: List[ChatMessage] = []
        self.max_history = 100  # ÏµúÎåÄ Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Ïàò

    async def add_user(self, websocket: WebSocketServerProtocol, username: str) -> User:
        """ÏÇ¨Ïö©Ïûê Ï∂îÍ∞Ä"""
        user_id = str(uuid.uuid4())
        now = datetime.now()

        user = User(
            id=user_id,
            username=username,
            websocket=websocket,
            joined_at=now,
            last_activity=now,
        )

        self.users[user_id] = user

        # ÏûÖÏû• Î©îÏãúÏßÄ ÏÉùÏÑ±
        join_message = ChatMessage(
            id=str(uuid.uuid4()),
            user_id="system",
            username="System",
            message=f"{username}ÎãòÏù¥ ÏûÖÏû•ÌñàÏäµÎãàÎã§.",
            timestamp=now,
            message_type=MessageType.JOIN,
        )

        await self.broadcast_message(join_message)
        await self.send_user_list()

        logger.info(f"ÏÇ¨Ïö©Ïûê Ï∂îÍ∞Ä: {username} (ID: {user_id})")
        return user

    async def remove_user(self, user_id: str) -> None:
        """ÏÇ¨Ïö©Ïûê Ï†úÍ±∞"""
        if user_id in self.users:
            user = self.users[user_id]
            del self.users[user_id]

            # Ìá¥Ïû• Î©îÏãúÏßÄ ÏÉùÏÑ±
            leave_message = ChatMessage(
                id=str(uuid.uuid4()),
                user_id="system",
                username="System",
                message=f"{user.username}ÎãòÏù¥ Ìá¥Ïû•ÌñàÏäµÎãàÎã§.",
                timestamp=datetime.now(),
                message_type=MessageType.LEAVE,
            )

            await self.broadcast_message(leave_message)
            await self.send_user_list()

            logger.info(f"ÏÇ¨Ïö©Ïûê Ï†úÍ±∞: {user.username} (ID: {user_id})")

    async def send_message(self, user_id: str, message: str) -> None:
        """Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        if user_id not in self.users:
            return

        user = self.users[user_id]
        user.last_activity = datetime.now()

        # Ï±ÑÌåÖ Î©îÏãúÏßÄ ÏÉùÏÑ±
        chat_message = ChatMessage(
            id=str(uuid.uuid4()),
            user_id=user_id,
            username=user.username,
            message=message,
            timestamp=datetime.now(),
        )

        # Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨Ïóê Ï∂îÍ∞Ä
        self.message_history.append(chat_message)
        if len(self.message_history) > self.max_history:
            self.message_history.pop(0)

        # Î™®Îì† ÏÇ¨Ïö©ÏûêÏóêÍ≤å Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
        await self.broadcast_message(chat_message)

    async def broadcast_message(self, message: ChatMessage) -> None:
        """Î©îÏãúÏßÄ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏"""
        if not self.users:
            return

        message_data = json.dumps(message.to_dict())
        disconnected_users = []

        for user in self.users.values():
            try:
                await user.websocket.send(message_data)
            except ConnectionClosed:
                disconnected_users.append(user.id)
            except Exception as e:
                logger.error(f"Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå® (ÏÇ¨Ïö©Ïûê: {user.username}): {e}")
                disconnected_users.append(user.id)

        # Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßÑ ÏÇ¨Ïö©ÏûêÎì§ Ï†úÍ±∞
        for user_id in disconnected_users:
            await self.remove_user(user_id)

    async def send_user_list(self) -> None:
        """ÏÇ¨Ïö©Ïûê Î™©Î°ù Ï†ÑÏÜ°"""
        user_list_data = {
            "type": MessageType.USER_LIST.value,
            "users": [user.to_dict() for user in self.users.values()],
            "timestamp": datetime.now().isoformat(),
        }

        message_data = json.dumps(user_list_data)
        disconnected_users = []

        for user in self.users.values():
            try:
                await user.websocket.send(message_data)
            except ConnectionClosed:
                disconnected_users.append(user.id)
            except Exception as e:
                logger.error(f"ÏÇ¨Ïö©Ïûê Î™©Î°ù Ï†ÑÏÜ° Ïã§Ìå® (ÏÇ¨Ïö©Ïûê: {user.username}): {e}")
                disconnected_users.append(user.id)

        # Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßÑ ÏÇ¨Ïö©ÏûêÎì§ Ï†úÍ±∞
        for user_id in disconnected_users:
            await self.remove_user(user_id)

    async def send_message_history(self, user_id: str, limit: int = 20) -> None:
        """Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Ï†ÑÏÜ°"""
        if user_id not in self.users:
            return

        user = self.users[user_id]
        recent_messages = self.message_history[-limit:] if self.message_history else []

        history_data = {
            "type": "message_history",
            "messages": [msg.to_dict() for msg in recent_messages],
            "timestamp": datetime.now().isoformat(),
        }

        try:
            await user.websocket.send(json.dumps(history_data))
        except Exception as e:
            logger.error(f"Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Ï†ÑÏÜ° Ïã§Ìå®: {e}")

    def get_room_stats(self) -> dict:
        """Ï±ÑÌåÖÎ∞© ÌÜµÍ≥Ñ"""
        return {
            "room_id": self.room_id,
            "user_count": len(self.users),
            "message_count": len(self.message_history),
            "users": [user.to_dict() for user in self.users.values()],
        }


class ChatServer:
    """Ï±ÑÌåÖ ÏÑúÎ≤Ñ ÌÅ¥ÎûòÏä§"""

    def __init__(self, host: str = "localhost", port: int = 8765):
        self.host = host
        self.port = port
        self.chat_room = ChatRoom()
        self.heartbeat_interval = 30  # 30Ï¥àÎßàÎã§ ÌïòÌä∏ÎπÑÌä∏

    async def handle_client(
        self, websocket: WebSocketServerProtocol, path: str
    ) -> None:
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï≤òÎ¶¨"""
        user = None

        try:
            # ÏÇ¨Ïö©ÏûêÎ™Ö ÏöîÏ≤≠
            await websocket.send(
                json.dumps(
                    {"type": "request_username", "message": "ÏÇ¨Ïö©ÏûêÎ™ÖÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:"}
                )
            )

            # ÏÇ¨Ïö©ÏûêÎ™Ö ÏàòÏã†
            username_response = await websocket.recv()
            username_data = json.loads(username_response)
            username = username_data.get("username", f"User_{uuid.uuid4().hex[:8]}")

            # ÏÇ¨Ïö©Ïûê Ï∂îÍ∞Ä
            user = await self.chat_room.add_user(websocket, username)

            # Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Ï†ÑÏÜ°
            await self.chat_room.send_message_history(user.id, 20)

            # Î©îÏãúÏßÄ ÏàòÏã† Î£®ÌîÑ
            async for message in websocket:
                await self.process_message(user, message)

        except ConnectionClosed:
            logger.info("ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞Ïù¥ Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§")
        except Exception as e:
            logger.error(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}")
        finally:
            if user:
                await self.chat_room.remove_user(user.id)

    async def process_message(self, user: User, message: str) -> None:
        """Î©îÏãúÏßÄ Ï≤òÎ¶¨"""
        try:
            data = json.loads(message)
            message_type = data.get("type", "message")

            if message_type == "chat_message":
                # Ï±ÑÌåÖ Î©îÏãúÏßÄ
                chat_text = data.get("message", "").strip()
                if chat_text:
                    await self.chat_room.send_message(user.id, chat_text)

            elif message_type == "heartbeat":
                # ÌïòÌä∏ÎπÑÌä∏ ÏùëÎãµ
                user.last_activity = datetime.now()
                await user.websocket.send(
                    json.dumps(
                        {
                            "type": "heartbeat_response",
                            "timestamp": datetime.now().isoformat(),
                        }
                    )
                )

            elif message_type == "get_users":
                # ÏÇ¨Ïö©Ïûê Î™©Î°ù ÏöîÏ≤≠
                await self.chat_room.send_user_list()

            elif message_type == "get_history":
                # Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ ÏöîÏ≤≠
                limit = data.get("limit", 20)
                await self.chat_room.send_message_history(user.id, limit)

            else:
                # Ïïå Ïàò ÏóÜÎäî Î©îÏãúÏßÄ ÌÉÄÏûÖ
                await user.websocket.send(
                    json.dumps(
                        {
                            "type": "error",
                            "message": f"Ïïå Ïàò ÏóÜÎäî Î©îÏãúÏßÄ ÌÉÄÏûÖ: {message_type}",
                            "timestamp": datetime.now().isoformat(),
                        }
                    )
                )

        except json.JSONDecodeError:
            # JSONÏù¥ ÏïÑÎãå ÏùºÎ∞ò ÌÖçÏä§Ìä∏ Î©îÏãúÏßÄ
            if message.strip():
                await self.chat_room.send_message(user.id, message)
        except Exception as e:
            logger.error(f"Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

    async def heartbeat_monitor(self) -> None:
        """ÌïòÌä∏ÎπÑÌä∏ Î™®ÎãàÌÑ∞ÎßÅ"""
        while True:
            await asyncio.sleep(self.heartbeat_interval)

            current_time = datetime.now()
            inactive_users = []

            # ÎπÑÌôúÏÑ± ÏÇ¨Ïö©Ïûê ÌôïÏù∏
            for user in self.chat_room.users.values():
                time_diff = (current_time - user.last_activity).total_seconds()
                if time_diff > self.heartbeat_interval * 2:  # 2Î∞∞ ÏãúÍ∞Ñ ÎèôÏïà ÎπÑÌôúÏÑ±
                    inactive_users.append(user.id)

            # ÎπÑÌôúÏÑ± ÏÇ¨Ïö©Ïûê Ï†úÍ±∞
            for user_id in inactive_users:
                await self.chat_room.remove_user(user_id)
                logger.info(f"ÎπÑÌôúÏÑ± ÏÇ¨Ïö©Ïûê Ï†úÍ±∞: {user_id}")

    async def start_server(self) -> None:
        """ÏÑúÎ≤Ñ ÏãúÏûë"""
        logger.info(f"Ï±ÑÌåÖ ÏÑúÎ≤Ñ ÏãúÏûë: ws://{self.host}:{self.port}")

        # ÌïòÌä∏ÎπÑÌä∏ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
        heartbeat_task = asyncio.create_task(self.heartbeat_monitor())

        try:
            async with websockets.serve(
                self.handle_client,
                self.host,
                self.port,
                ping_interval=20,
                ping_timeout=10,
                close_timeout=10,
            ):
                logger.info("Ï±ÑÌåÖ ÏÑúÎ≤ÑÍ∞Ä Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§. Ctrl+CÎ°ú Ï¢ÖÎ£åÌïòÏÑ∏Ïöî.")
                await asyncio.Future()  # ÏÑúÎ≤ÑÎ•º Í≥ÑÏÜç Ïã§Ìñâ
        finally:
            heartbeat_task.cancel()


class ChatClient:
    """Ï±ÑÌåÖ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌÅ¥ÎûòÏä§"""

    def __init__(self, uri: str, username: str):
        self.uri = uri
        self.username = username
        self.websocket: Optional[websockets.WebSocketServerProtocol] = None
        self.running = False

    async def connect(self) -> None:
        """ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞"""
        try:
            self.websocket = await websockets.connect(self.uri)
            self.running = True
            logger.info(f"Ï±ÑÌåÖ ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞Îê®: {self.uri}")

            # ÏÇ¨Ïö©ÏûêÎ™Ö Ï†ÑÏÜ°
            await self.websocket.send(json.dumps({"username": self.username}))

        except Exception as e:
            logger.error(f"ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå®: {e}")
            raise

    async def disconnect(self) -> None:
        """ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ìï¥Ï†ú"""
        self.running = False
        if self.websocket:
            await self.websocket.close()
            logger.info("ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ìï¥Ï†ú")

    async def send_message(self, message: str) -> None:
        """Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        if not self.websocket or not self.running:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        message_data = {"type": "chat_message", "message": message}
        await self.websocket.send(json.dumps(message_data))

    async def listen_for_messages(self) -> None:
        """Î©îÏãúÏßÄ ÏàòÏã† ÎåÄÍ∏∞"""
        if not self.websocket:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        try:
            async for message in self.websocket:
                if not self.running:
                    break

                try:
                    data = json.loads(message)
                    message_type = data.get("type", "unknown")

                    if message_type == "request_username":
                        # ÏÇ¨Ïö©ÏûêÎ™Ö ÏöîÏ≤≠ (Ïù¥ÎØ∏ Ïó∞Í≤∞ Ïãú Ï†ÑÏÜ°Îê®)
                        continue
                    elif message_type == "message_history":
                        # Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨
                        messages = data.get("messages", [])
                        print(f"\n=== ÏµúÍ∑º Î©îÏãúÏßÄ ({len(messages)}Í∞ú) ===")
                        for msg in messages:
                            timestamp = datetime.fromisoformat(msg["timestamp"])
                            print(
                                f"[{timestamp.strftime('%H:%M:%S')}] {msg['username']}: {msg['message']}"
                            )
                        print("=== ÌòÑÏû¨ Ï±ÑÌåÖ ===\n")
                    elif message_type == "user_list":
                        # ÏÇ¨Ïö©Ïûê Î™©Î°ù
                        users = data.get("users", [])
                        print(
                            f"\nÌòÑÏû¨ Ï†ëÏÜçÏûê ({len(users)}Î™Ö): {', '.join([u['username'] for u in users])}\n"
                        )
                    elif message_type in ["join", "leave"]:
                        # ÏûÖÏû•/Ìá¥Ïû• Î©îÏãúÏßÄ
                        print(f"üì¢ {data.get('message', '')}")
                    elif message_type == "error":
                        # Ïò§Î•ò Î©îÏãúÏßÄ
                        print(f"‚ùå Ïò§Î•ò: {data.get('message', '')}")
                    else:
                        # ÏùºÎ∞ò Ï±ÑÌåÖ Î©îÏãúÏßÄ
                        timestamp = datetime.fromisoformat(data["timestamp"])
                        print(
                            f"[{timestamp.strftime('%H:%M:%S')}] {data['username']}: {data['message']}"
                        )

                except json.JSONDecodeError:
                    # JSONÏù¥ ÏïÑÎãå ÏùºÎ∞ò ÌÖçÏä§Ìä∏
                    print(f"ÏÑúÎ≤Ñ Î©îÏãúÏßÄ: {message}")

        except ConnectionClosed:
            logger.info("ÏÑúÎ≤Ñ Ïó∞Í≤∞Ïù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§")
        except Exception as e:
            logger.error(f"Î©îÏãúÏßÄ ÏàòÏã† Ï§ë Ïò§Î•ò: {e}")

    async def start_interactive_mode(self) -> None:
        """ÎåÄÌôîÌòï Î™®Îìú ÏãúÏûë"""
        print(f"Ï±ÑÌåÖ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏãúÏûë (ÏÇ¨Ïö©Ïûê: {self.username})")
        print("Î™ÖÎ†πÏñ¥: /users (ÏÇ¨Ïö©Ïûê Î™©Î°ù), /history (Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨), /quit (Ï¢ÖÎ£å)")
        print("-" * 50)

        # Î©îÏãúÏßÄ ÏàòÏã† ÌÉúÏä§ÌÅ¨ ÏãúÏûë
        receive_task = asyncio.create_task(self.listen_for_messages())

        try:
            while self.running:
                # ÏÇ¨Ïö©Ïûê ÏûÖÎ†• Î∞õÍ∏∞
                try:
                    user_input = await asyncio.wait_for(
                        asyncio.get_event_loop().run_in_executor(None, input),
                        timeout=1.0,
                    )

                    if user_input.strip():
                        if user_input.strip() == "/quit":
                            break
                        elif user_input.strip() == "/users":
                            await self.websocket.send(json.dumps({"type": "get_users"}))
                        elif user_input.strip() == "/history":
                            await self.websocket.send(
                                json.dumps({"type": "get_history", "limit": 10})
                            )
                        else:
                            await self.send_message(user_input)

                except asyncio.TimeoutError:
                    # ÌÉÄÏûÑÏïÑÏõÉÏùÄ Ï†ïÏÉÅ (ÏûÖÎ†• ÎåÄÍ∏∞ Ï§ë)
                    continue
                except KeyboardInterrupt:
                    break

        finally:
            self.running = False
            receive_task.cancel()
            try:
                await receive_task
            except asyncio.CancelledError:
                pass


async def demo_chat_server():
    """Ï±ÑÌåÖ ÏÑúÎ≤Ñ Îç∞Î™®"""
    server = ChatServer()
    await server.start_server()


async def demo_chat_client():
    """Ï±ÑÌåÖ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îç∞Î™®"""
    import random

    username = f"User_{random.randint(1000, 9999)}"
    client = ChatClient("ws://localhost:8765", username)

    try:
        await client.connect()
        await client.start_interactive_mode()
    finally:
        await client.disconnect()


async def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    print("Ïã§ÏãúÍ∞Ñ Ï±ÑÌåÖ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Îç∞Î™®")
    print("1. ÏÑúÎ≤Ñ Ïã§Ìñâ")
    print("2. ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïã§Ìñâ")
    print("3. Ï¢ÖÎ£å")

    choice = input("ÏÑ†ÌÉùÌïòÏÑ∏Ïöî (1-3): ").strip()

    if choice == "1":
        print("Ï±ÑÌåÖ ÏÑúÎ≤ÑÎ•º ÏãúÏûëÌï©ÎãàÎã§...")
        await demo_chat_server()
    elif choice == "2":
        print("Ï±ÑÌåÖ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º ÏãúÏûëÌï©ÎãàÎã§...")
        await demo_chat_client()
    else:
        print("ÌîÑÎ°úÍ∑∏Îû®ÏùÑ Ï¢ÖÎ£åÌï©ÎãàÎã§.")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="04_advanced_websocket.py">
"""
Í≥†Í∏â ÏõπÏÜåÏºì Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò
Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïä§Ìä∏Î¶¨Î∞ç, Î™®ÎãàÌÑ∞ÎßÅ, Î∂ÄÌïò Î∂ÑÏÇ∞ Îì± Í≥†Í∏â Í∏∞Îä• Íµ¨ÌòÑ
"""

import asyncio
import json
import logging
import random
import time
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set, Any, Callable
from dataclasses import dataclass, asdict
from enum import Enum
from collections import defaultdict, deque
import statistics

try:
    import websockets
    from websockets.server import WebSocketServerProtocol
    from websockets.exceptions import ConnectionClosed
except ImportError:
    print("websockets ÎùºÏù¥Î∏åÎü¨Î¶¨Í∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
    print("Îã§Ïùå Î™ÖÎ†πÏñ¥Î°ú ÏÑ§ÏπòÌïòÏÑ∏Ïöî: pip install websockets")
    exit(1)

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class StreamType(Enum):
    """Ïä§Ìä∏Î¶º ÌÉÄÏûÖ"""

    SENSOR_DATA = "sensor_data"
    SYSTEM_METRICS = "system_metrics"
    USER_ACTIVITY = "user_activity"
    MARKET_DATA = "market_data"
    LOG_EVENTS = "log_events"


@dataclass
class StreamData:
    """Ïä§Ìä∏Î¶º Îç∞Ïù¥ÌÑ∞"""

    id: str
    stream_type: StreamType
    data: Dict[str, Any]
    timestamp: datetime
    source: str

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "stream_type": self.stream_type.value,
            "data": self.data,
            "timestamp": self.timestamp.isoformat(),
            "source": self.source,
        }


@dataclass
class ClientSubscription:
    """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Íµ¨ÎèÖ Ï†ïÎ≥¥"""

    client_id: str
    stream_types: Set[StreamType]
    filters: Dict[str, Any]
    last_activity: datetime


class StreamProcessor:
    """Ïä§Ìä∏Î¶º Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨Í∏∞"""

    def __init__(self):
        self.processors: Dict[StreamType, List[Callable]] = defaultdict(list)
        self.aggregators: Dict[StreamType, deque] = defaultdict(
            lambda: deque(maxlen=1000)
        )

    def register_processor(self, stream_type: StreamType, processor: Callable) -> None:
        """Ïä§Ìä∏Î¶º Ï≤òÎ¶¨Í∏∞ Îì±Î°ù"""
        self.processors[stream_type].append(processor)

    async def process_data(self, data: StreamData) -> StreamData:
        """Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨"""
        # Îç∞Ïù¥ÌÑ∞ ÏßëÍ≥Ñ
        self.aggregators[data.stream_type].append(data)

        # Îì±Î°ùÎêú Ï≤òÎ¶¨Í∏∞Îì§ Ïã§Ìñâ
        for processor in self.processors[data.stream_type]:
            try:
                data = await processor(data)
            except Exception as e:
                logger.error(f"Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

        return data

    def get_aggregated_data(
        self, stream_type: StreamType, window_size: int = 100
    ) -> Dict[str, Any]:
        """ÏßëÍ≥ÑÎêú Îç∞Ïù¥ÌÑ∞ Î∞òÌôò"""
        data_points = list(self.aggregators[stream_type])[-window_size:]

        if not data_points:
            return {}

        # Í∏∞Î≥∏ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        if stream_type == StreamType.SENSOR_DATA:
            values = [point.data.get("value", 0) for point in data_points]
            return {
                "count": len(values),
                "mean": statistics.mean(values),
                "min": min(values),
                "max": max(values),
                "std": statistics.stdev(values) if len(values) > 1 else 0,
                "latest": values[-1] if values else None,
            }
        elif stream_type == StreamType.SYSTEM_METRICS:
            cpu_values = [point.data.get("cpu_usage", 0) for point in data_points]
            memory_values = [point.data.get("memory_usage", 0) for point in data_points]
            return {
                "cpu": {
                    "mean": statistics.mean(cpu_values),
                    "max": max(cpu_values),
                    "current": cpu_values[-1] if cpu_values else None,
                },
                "memory": {
                    "mean": statistics.mean(memory_values),
                    "max": max(memory_values),
                    "current": memory_values[-1] if memory_values else None,
                },
            }

        return {"count": len(data_points)}


class LoadBalancer:
    """Î°úÎìú Î∞∏Îü∞ÏÑú"""

    def __init__(self):
        self.servers: Dict[str, Dict[str, Any]] = {}
        self.server_weights: Dict[str, float] = {}
        self.current_connections: Dict[str, int] = defaultdict(int)

    def add_server(self, server_id: str, capacity: int, weight: float = 1.0) -> None:
        """ÏÑúÎ≤Ñ Ï∂îÍ∞Ä"""
        self.servers[server_id] = {
            "capacity": capacity,
            "weight": weight,
            "status": "active",
        }
        self.server_weights[server_id] = weight

    def get_best_server(self) -> Optional[str]:
        """ÏµúÏ†Å ÏÑúÎ≤Ñ ÏÑ†ÌÉù"""
        available_servers = [
            server_id
            for server_id, server in self.servers.items()
            if server["status"] == "active"
            and self.current_connections[server_id] < server["capacity"]
        ]

        if not available_servers:
            return None

        # Í∞ÄÏ§ëÏπò Í∏∞Î∞ò ÏÑ†ÌÉù
        total_weight = sum(
            self.server_weights[server_id] for server_id in available_servers
        )
        if total_weight == 0:
            return available_servers[0]

        choice = random.uniform(0, total_weight)
        current_weight = 0

        for server_id in available_servers:
            current_weight += self.server_weights[server_id]
            if choice <= current_weight:
                return server_id

        return available_servers[-1]

    def update_connections(self, server_id: str, delta: int) -> None:
        """Ïó∞Í≤∞ Ïàò ÏóÖÎç∞Ïù¥Ìä∏"""
        self.current_connections[server_id] += delta
        self.current_connections[server_id] = max(
            0, self.current_connections[server_id]
        )


class AdvancedWebSocketServer:
    """Í≥†Í∏â ÏõπÏÜåÏºì ÏÑúÎ≤Ñ"""

    def __init__(self, host: str = "localhost", port: int = 8765):
        self.host = host
        self.port = port
        self.clients: Dict[str, WebSocketServerProtocol] = {}
        self.subscriptions: Dict[str, ClientSubscription] = {}
        self.stream_processor = StreamProcessor()
        self.load_balancer = LoadBalancer()
        self.metrics = {
            "total_connections": 0,
            "active_connections": 0,
            "messages_sent": 0,
            "messages_received": 0,
            "start_time": datetime.now(),
        }

        # Ïä§Ìä∏Î¶º ÏÉùÏÑ±Í∏∞ Îì±Î°ù
        self._register_stream_generators()
        self._register_data_processors()

    def _register_stream_generators(self) -> None:
        """Ïä§Ìä∏Î¶º ÏÉùÏÑ±Í∏∞ Îì±Î°ù"""
        asyncio.create_task(self._generate_sensor_data())
        asyncio.create_task(self._generate_system_metrics())
        asyncio.create_task(self._generate_user_activity())
        asyncio.create_task(self._generate_market_data())

    def _register_data_processors(self) -> None:
        """Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨Í∏∞ Îì±Î°ù"""

        # ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ïù¥ÏÉÅÏπò ÌÉêÏßÄ
        async def detect_anomalies(data: StreamData) -> StreamData:
            if data.stream_type == StreamType.SENSOR_DATA:
                value = data.data.get("value", 0)
                aggregated = self.stream_processor.get_aggregated_data(
                    StreamType.SENSOR_DATA
                )

                if aggregated and "mean" in aggregated and "std" in aggregated:
                    mean = aggregated["mean"]
                    std = aggregated["std"]

                    if std > 0 and abs(value - mean) > 3 * std:  # 3ÏãúÍ∑∏Îßà Í∑úÏπô
                        data.data["anomaly"] = True
                        data.data["anomaly_score"] = abs(value - mean) / std
                        logger.warning(
                            f"Ïù¥ÏÉÅÏπò ÌÉêÏßÄ: {value} (ÌèâÍ∑†: {mean:.2f}, ÌëúÏ§ÄÌé∏Ï∞®: {std:.2f})"
                        )

            return data

        # ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨
        async def check_thresholds(data: StreamData) -> StreamData:
            if data.stream_type == StreamType.SYSTEM_METRICS:
                cpu = data.data.get("cpu_usage", 0)
                memory = data.data.get("memory_usage", 0)

                if cpu > 80:
                    data.data["cpu_alert"] = True
                    logger.warning(f"ÎÜíÏùÄ CPU ÏÇ¨Ïö©Î•†: {cpu}%")

                if memory > 90:
                    data.data["memory_alert"] = True
                    logger.warning(f"ÎÜíÏùÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•†: {memory}%")

            return data

        self.stream_processor.register_processor(
            StreamType.SENSOR_DATA, detect_anomalies
        )
        self.stream_processor.register_processor(
            StreamType.SYSTEM_METRICS, check_thresholds
        )

    async def _generate_sensor_data(self) -> None:
        """ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±"""
        while True:
            await asyncio.sleep(1)  # 1Ï¥àÎßàÎã§

            data = StreamData(
                id=str(uuid.uuid4()),
                stream_type=StreamType.SENSOR_DATA,
                data={
                    "value": random.uniform(20, 30),  # Ïò®ÎèÑ ÏÑºÏÑú
                    "unit": "celsius",
                    "location": random.choice(["room1", "room2", "room3"]),
                },
                timestamp=datetime.now(),
                source="temperature_sensor",
            )

            await self._broadcast_stream_data(data)

    async def _generate_system_metrics(self) -> None:
        """ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ ÏÉùÏÑ±"""
        while True:
            await asyncio.sleep(2)  # 2Ï¥àÎßàÎã§

            data = StreamData(
                id=str(uuid.uuid4()),
                stream_type=StreamType.SYSTEM_METRICS,
                data={
                    "cpu_usage": random.uniform(10, 100),
                    "memory_usage": random.uniform(30, 95),
                    "disk_usage": random.uniform(20, 80),
                    "network_io": random.uniform(0, 1000),
                },
                timestamp=datetime.now(),
                source="system_monitor",
            )

            await self._broadcast_stream_data(data)

    async def _generate_user_activity(self) -> None:
        """ÏÇ¨Ïö©Ïûê ÌôúÎèô Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±"""
        while True:
            await asyncio.sleep(5)  # 5Ï¥àÎßàÎã§

            data = StreamData(
                id=str(uuid.uuid4()),
                stream_type=StreamType.USER_ACTIVITY,
                data={
                    "user_id": f"user_{random.randint(1, 100)}",
                    "action": random.choice(
                        ["login", "logout", "page_view", "click", "purchase"]
                    ),
                    "page": random.choice(["/home", "/products", "/cart", "/checkout"]),
                    "session_duration": random.uniform(0, 3600),
                },
                timestamp=datetime.now(),
                source="user_tracker",
            )

            await self._broadcast_stream_data(data)

    async def _generate_market_data(self) -> None:
        """ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±"""
        while True:
            await asyncio.sleep(0.5)  # 0.5Ï¥àÎßàÎã§

            data = StreamData(
                id=str(uuid.uuid4()),
                stream_type=StreamType.MARKET_DATA,
                data={
                    "symbol": random.choice(["AAPL", "GOOGL", "MSFT", "TSLA"]),
                    "price": random.uniform(100, 500),
                    "volume": random.randint(1000, 10000),
                    "change": random.uniform(-5, 5),
                },
                timestamp=datetime.now(),
                source="market_feed",
            )

            await self._broadcast_stream_data(data)

    async def _broadcast_stream_data(self, data: StreamData) -> None:
        """Ïä§Ìä∏Î¶º Îç∞Ïù¥ÌÑ∞ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏"""
        # Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
        processed_data = await self.stream_processor.process_data(data)

        # Íµ¨ÎèÖÏûêÎì§ÏóêÍ≤å Ï†ÑÏÜ°
        for client_id, subscription in self.subscriptions.items():
            if data.stream_type in subscription.stream_types:
                if client_id in self.clients:
                    try:
                        message = json.dumps(processed_data.to_dict())
                        await self.clients[client_id].send(message)
                        self.metrics["messages_sent"] += 1
                    except ConnectionClosed:
                        await self._remove_client(client_id)
                    except Exception as e:
                        logger.error(f"Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå® (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏: {client_id}): {e}")

    async def handle_client(
        self, websocket: WebSocketServerProtocol, path: str
    ) -> None:
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï≤òÎ¶¨"""
        client_id = str(uuid.uuid4())
        self.clients[client_id] = websocket
        self.metrics["total_connections"] += 1
        self.metrics["active_connections"] += 1

        logger.info(
            f"ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞: {client_id} (Ï¥ù Ïó∞Í≤∞: {self.metrics['active_connections']})"
        )

        try:
            async for message in websocket:
                await self._process_client_message(client_id, message)
        except ConnectionClosed:
            logger.info(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï¢ÖÎ£å: {client_id}")
        except Exception as e:
            logger.error(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏: {client_id}): {e}")
        finally:
            await self._remove_client(client_id)

    async def _process_client_message(self, client_id: str, message: str) -> None:
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î©îÏãúÏßÄ Ï≤òÎ¶¨"""
        self.metrics["messages_received"] += 1

        try:
            data = json.loads(message)
            message_type = data.get("type", "unknown")

            if message_type == "subscribe":
                # Ïä§Ìä∏Î¶º Íµ¨ÎèÖ
                stream_types = [StreamType(t) for t in data.get("stream_types", [])]
                filters = data.get("filters", {})

                self.subscriptions[client_id] = ClientSubscription(
                    client_id=client_id,
                    stream_types=set(stream_types),
                    filters=filters,
                    last_activity=datetime.now(),
                )

                await self._send_response(
                    client_id,
                    {
                        "type": "subscription_confirmed",
                        "stream_types": [t.value for t in stream_types],
                        "timestamp": datetime.now().isoformat(),
                    },
                )

            elif message_type == "unsubscribe":
                # Íµ¨ÎèÖ Ìï¥Ï†ú
                if client_id in self.subscriptions:
                    del self.subscriptions[client_id]

                await self._send_response(
                    client_id,
                    {
                        "type": "unsubscription_confirmed",
                        "timestamp": datetime.now().isoformat(),
                    },
                )

            elif message_type == "get_metrics":
                # ÏÑúÎ≤Ñ Î©îÌä∏Î¶≠ ÏöîÏ≤≠
                await self._send_response(
                    client_id,
                    {
                        "type": "server_metrics",
                        "metrics": self.metrics,
                        "uptime": (
                            datetime.now() - self.metrics["start_time"]
                        ).total_seconds(),
                        "timestamp": datetime.now().isoformat(),
                    },
                )

            elif message_type == "get_aggregated_data":
                # ÏßëÍ≥ÑÎêú Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠
                stream_type = StreamType(data.get("stream_type", "sensor_data"))
                window_size = data.get("window_size", 100)

                aggregated = self.stream_processor.get_aggregated_data(
                    stream_type, window_size
                )

                await self._send_response(
                    client_id,
                    {
                        "type": "aggregated_data",
                        "stream_type": stream_type.value,
                        "data": aggregated,
                        "timestamp": datetime.now().isoformat(),
                    },
                )

            elif message_type == "ping":
                # Ìïë ÏùëÎãµ
                await self._send_response(
                    client_id, {"type": "pong", "timestamp": datetime.now().isoformat()}
                )

            else:
                # Ïïå Ïàò ÏóÜÎäî Î©îÏãúÏßÄ ÌÉÄÏûÖ
                await self._send_response(
                    client_id,
                    {
                        "type": "error",
                        "message": f"Ïïå Ïàò ÏóÜÎäî Î©îÏãúÏßÄ ÌÉÄÏûÖ: {message_type}",
                        "timestamp": datetime.now().isoformat(),
                    },
                )

        except json.JSONDecodeError:
            await self._send_response(
                client_id,
                {
                    "type": "error",
                    "message": "Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ JSON Î©îÏãúÏßÄ",
                    "timestamp": datetime.now().isoformat(),
                },
            )
        except Exception as e:
            logger.error(f"Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: {e}")
            await self._send_response(
                client_id,
                {
                    "type": "error",
                    "message": f"ÏÑúÎ≤Ñ Ïò§Î•ò: {str(e)}",
                    "timestamp": datetime.now().isoformat(),
                },
            )

    async def _send_response(self, client_id: str, response: dict) -> None:
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å ÏùëÎãµ Ï†ÑÏÜ°"""
        if client_id in self.clients:
            try:
                await self.clients[client_id].send(json.dumps(response))
                self.metrics["messages_sent"] += 1
            except ConnectionClosed:
                await self._remove_client(client_id)
            except Exception as e:
                logger.error(f"ÏùëÎãµ Ï†ÑÏÜ° Ïã§Ìå® (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏: {client_id}): {e}")

    async def _remove_client(self, client_id: str) -> None:
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†úÍ±∞"""
        if client_id in self.clients:
            del self.clients[client_id]
            self.metrics["active_connections"] -= 1

        if client_id in self.subscriptions:
            del self.subscriptions[client_id]

        logger.info(
            f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†úÍ±∞: {client_id} (ÌôúÏÑ± Ïó∞Í≤∞: {self.metrics['active_connections']})"
        )

    async def start_server(self) -> None:
        """ÏÑúÎ≤Ñ ÏãúÏûë"""
        logger.info(f"Í≥†Í∏â ÏõπÏÜåÏºì ÏÑúÎ≤Ñ ÏãúÏûë: ws://{self.host}:{self.port}")

        async with websockets.serve(
            self.handle_client,
            self.host,
            self.port,
            ping_interval=30,
            ping_timeout=10,
            close_timeout=10,
        ):
            logger.info("ÏÑúÎ≤ÑÍ∞Ä Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§. Ctrl+CÎ°ú Ï¢ÖÎ£åÌïòÏÑ∏Ïöî.")
            await asyncio.Future()


class AdvancedWebSocketClient:
    """Í≥†Í∏â ÏõπÏÜåÏºì ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏"""

    def __init__(self, uri: str, client_name: str = "AdvancedClient"):
        self.uri = uri
        self.client_name = client_name
        self.websocket: Optional[websockets.WebSocketServerProtocol] = None
        self.running = False
        self.subscriptions: Set[StreamType] = set()

    async def connect(self) -> None:
        """ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞"""
        try:
            self.websocket = await websockets.connect(self.uri)
            self.running = True
            logger.info(f"ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞Îê®: {self.uri}")
        except Exception as e:
            logger.error(f"ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå®: {e}")
            raise

    async def disconnect(self) -> None:
        """ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ìï¥Ï†ú"""
        self.running = False
        if self.websocket:
            await self.websocket.close()
            logger.info("ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ìï¥Ï†ú")

    async def subscribe(
        self, stream_types: List[StreamType], filters: Dict[str, Any] = None
    ) -> None:
        """Ïä§Ìä∏Î¶º Íµ¨ÎèÖ"""
        if not self.websocket:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        message = {
            "type": "subscribe",
            "stream_types": [t.value for t in stream_types],
            "filters": filters or {},
        }

        await self.websocket.send(json.dumps(message))
        self.subscriptions.update(stream_types)
        logger.info(f"Íµ¨ÎèÖ ÏöîÏ≤≠: {[t.value for t in stream_types]}")

    async def unsubscribe(self) -> None:
        """Íµ¨ÎèÖ Ìï¥Ï†ú"""
        if not self.websocket:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        message = {"type": "unsubscribe"}
        await self.websocket.send(json.dumps(message))
        self.subscriptions.clear()
        logger.info("Íµ¨ÎèÖ Ìï¥Ï†ú")

    async def get_server_metrics(self) -> None:
        """ÏÑúÎ≤Ñ Î©îÌä∏Î¶≠ ÏöîÏ≤≠"""
        if not self.websocket:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        message = {"type": "get_metrics"}
        await self.websocket.send(json.dumps(message))

    async def get_aggregated_data(
        self, stream_type: StreamType, window_size: int = 100
    ) -> None:
        """ÏßëÍ≥ÑÎêú Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠"""
        if not self.websocket:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        message = {
            "type": "get_aggregated_data",
            "stream_type": stream_type.value,
            "window_size": window_size,
        }
        await self.websocket.send(json.dumps(message))

    async def listen_for_messages(self) -> None:
        """Î©îÏãúÏßÄ ÏàòÏã† ÎåÄÍ∏∞"""
        if not self.websocket:
            raise RuntimeError("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")

        try:
            async for message in self.websocket:
                if not self.running:
                    break

                try:
                    data = json.loads(message)
                    await self._handle_message(data)
                except json.JSONDecodeError:
                    logger.info(f"ÏàòÏã†Îêú Î©îÏãúÏßÄ: {message}")

        except ConnectionClosed:
            logger.info("ÏÑúÎ≤Ñ Ïó∞Í≤∞Ïù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§")
        except Exception as e:
            logger.error(f"Î©îÏãúÏßÄ ÏàòÏã† Ï§ë Ïò§Î•ò: {e}")

    async def _handle_message(self, data: dict) -> None:
        """Î©îÏãúÏßÄ Ï≤òÎ¶¨"""
        message_type = data.get("type", "unknown")

        if message_type == "subscription_confirmed":
            logger.info(f"Íµ¨ÎèÖ ÌôïÏù∏: {data.get('stream_types', [])}")

        elif message_type == "server_metrics":
            metrics = data.get("metrics", {})
            uptime = data.get("uptime", 0)
            print(f"\n=== ÏÑúÎ≤Ñ Î©îÌä∏Î¶≠ ===")
            print(f"ÌôúÏÑ± Ïó∞Í≤∞: {metrics.get('active_connections', 0)}")
            print(f"Ï¥ù Ïó∞Í≤∞: {metrics.get('total_connections', 0)}")
            print(f"Ï†ÑÏÜ°Îêú Î©îÏãúÏßÄ: {metrics.get('messages_sent', 0)}")
            print(f"ÏàòÏã†Îêú Î©îÏãúÏßÄ: {metrics.get('messages_received', 0)}")
            print(f"ÏóÖÌÉÄÏûÑ: {uptime:.2f}Ï¥à")
            print("=" * 20)

        elif message_type == "aggregated_data":
            stream_type = data.get("stream_type", "unknown")
            aggregated_data = data.get("data", {})
            print(f"\n=== {stream_type} ÏßëÍ≥Ñ Îç∞Ïù¥ÌÑ∞ ===")
            for key, value in aggregated_data.items():
                if isinstance(value, dict):
                    print(f"{key}:")
                    for sub_key, sub_value in value.items():
                        print(f"  {sub_key}: {sub_value}")
                else:
                    print(f"{key}: {value}")
            print("=" * 30)

        elif message_type in [
            "sensor_data",
            "system_metrics",
            "user_activity",
            "market_data",
        ]:
            # Ïä§Ìä∏Î¶º Îç∞Ïù¥ÌÑ∞ Ï∂úÎ†•
            timestamp = datetime.fromisoformat(data["timestamp"])
            source = data.get("source", "unknown")

            print(f"[{timestamp.strftime('%H:%M:%S')}] {message_type} from {source}")

            # ÌäπÎ≥ÑÌïú Îç∞Ïù¥ÌÑ∞ ÌëúÏãú
            if "anomaly" in data.get("data", {}):
                print("üö® Ïù¥ÏÉÅÏπò ÌÉêÏßÄ!")
            if "cpu_alert" in data.get("data", {}):
                print("‚ö†Ô∏è CPU Í≤ΩÍ≥†!")
            if "memory_alert" in data.get("data", {}):
                print("‚ö†Ô∏è Î©îÎ™®Î¶¨ Í≤ΩÍ≥†!")

        else:
            logger.info(f"ÏàòÏã†Îêú Î©îÏãúÏßÄ: {data}")


async def demo_advanced_server():
    """Í≥†Í∏â ÏÑúÎ≤Ñ Îç∞Î™®"""
    server = AdvancedWebSocketServer()
    await server.start_server()


async def demo_advanced_client():
    """Í≥†Í∏â ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îç∞Î™®"""
    client = AdvancedWebSocketClient("ws://localhost:8765", "DemoClient")

    try:
        await client.connect()

        # ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ÏôÄ ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ Íµ¨ÎèÖ
        await client.subscribe([StreamType.SENSOR_DATA, StreamType.SYSTEM_METRICS])

        # ÏÑúÎ≤Ñ Î©îÌä∏Î¶≠ ÏöîÏ≤≠
        await client.get_server_metrics()

        # Î©îÏãúÏßÄ ÏàòÏã† ÏãúÏûë
        await client.listen_for_messages()

    except KeyboardInterrupt:
        logger.info("ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¢ÖÎ£å")
    finally:
        await client.disconnect()


async def demo_data_analysis():
    """Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Îç∞Î™®"""
    client = AdvancedWebSocketClient("ws://localhost:8765", "AnalysisClient")

    try:
        await client.connect()

        # Î™®Îì† Ïä§Ìä∏Î¶º Íµ¨ÎèÖ
        await client.subscribe(
            [
                StreamType.SENSOR_DATA,
                StreamType.SYSTEM_METRICS,
                StreamType.USER_ACTIVITY,
                StreamType.MARKET_DATA,
            ]
        )

        # Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú ÏßëÍ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠
        async def periodic_analysis():
            while True:
                await asyncio.sleep(10)  # 10Ï¥àÎßàÎã§
                print("\n=== Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ===")
                await client.get_aggregated_data(StreamType.SENSOR_DATA, 50)
                await client.get_aggregated_data(StreamType.SYSTEM_METRICS, 50)
                await client.get_server_metrics()

        # Î∂ÑÏÑù ÌÉúÏä§ÌÅ¨ÏôÄ Î©îÏãúÏßÄ ÏàòÏã†ÏùÑ ÎèôÏãúÏóê Ïã§Ìñâ
        analysis_task = asyncio.create_task(periodic_analysis())

        try:
            await client.listen_for_messages()
        finally:
            analysis_task.cancel()
            try:
                await analysis_task
            except asyncio.CancelledError:
                pass

    except KeyboardInterrupt:
        logger.info("Î∂ÑÏÑù ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¢ÖÎ£å")
    finally:
        await client.disconnect()


async def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    print("Í≥†Í∏â ÏõπÏÜåÏºì Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Îç∞Î™®")
    print("1. ÏÑúÎ≤Ñ Ïã§Ìñâ")
    print("2. Í∏∞Î≥∏ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïã§Ìñâ")
    print("3. Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïã§Ìñâ")
    print("4. Ï¢ÖÎ£å")

    choice = input("ÏÑ†ÌÉùÌïòÏÑ∏Ïöî (1-4): ").strip()

    if choice == "1":
        print("Í≥†Í∏â ÏõπÏÜåÏºì ÏÑúÎ≤ÑÎ•º ÏãúÏûëÌï©ÎãàÎã§...")
        await demo_advanced_server()
    elif choice == "2":
        print("Í∏∞Î≥∏ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º ÏãúÏûëÌï©ÎãàÎã§...")
        await demo_advanced_client()
    elif choice == "3":
        print("Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º ÏãúÏûëÌï©ÎãàÎã§...")
        await demo_data_analysis()
    else:
        print("ÌîÑÎ°úÍ∑∏Îû®ÏùÑ Ï¢ÖÎ£åÌï©ÎãàÎã§.")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="package.json">
{}
</file>

<file path="quick_websocket_test.py">
#!/usr/bin/env python3
"""
Îπ†Î•∏ ÏõπÏÜåÏºì ÌÖåÏä§Ìä∏ - ÏõêÎ≥∏ ÏΩîÎìú ÏÇ¨Ïö©
"""
import asyncio
from websockets_test import test_websocket


async def main():
    # ÏÑúÎ≤Ñ ÏãúÏûë
    from websocket_basics import WebSocketServer

    server = WebSocketServer()
    server_task = asyncio.create_task(server.start_server())

    # Ïû†Ïãú ÎåÄÍ∏∞ ÌõÑ ÌÖåÏä§Ìä∏
    await asyncio.sleep(1)

    # Í∞ÑÎã®Ìïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌÖåÏä§Ìä∏
    import websockets
    import json

    try:
        async with websockets.connect("ws://localhost:8765") as websocket:
            print("‚úÖ Ïó∞Í≤∞ ÏÑ±Í≥µ")

            # ÌÖçÏä§Ìä∏ Î©îÏãúÏßÄ
            await websocket.send("Hello Server!")
            response = await websocket.recv()
            print(f"ÏùëÎãµ: {response}")

            # JSON Î©îÏãúÏßÄ
            await websocket.send(json.dumps({"type": "ping"}))
            response = await websocket.recv()
            print(f"Ìïë ÏùëÎãµ: {response}")

            print("‚úÖ ÏõπÏÜåÏºì Í∏∞Î≥∏ Í∏∞Îä• Ï†ïÏÉÅ ÏûëÎèô!")

    except Exception as e:
        print(f"‚ùå Ïò§Î•ò: {e}")

    # ÏÑúÎ≤Ñ Ï¢ÖÎ£å
    server_task.cancel()
    try:
        await server_task
    except asyncio.CancelledError:
        pass


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="README.md">
# asyncioÏôÄ ÏõπÏÜåÏºì Í∏∞Ï¥àÎ∂ÄÌÑ∞ Í≥†Í∏âÍπåÏßÄ

Ïù¥ ÌîÑÎ°úÏ†ùÌä∏Îäî PythonÏùò asyncioÏôÄ ÏõπÏÜåÏºìÏùÑ ÏÇ¨Ïö©Ìïú ÎπÑÎèôÍ∏∞ ÌîÑÎ°úÍ∑∏ÎûòÎ∞çÏùÑ Îã®Í≥ÑÏ†ÅÏúºÎ°ú ÌïôÏäµÌï† Ïàò ÏûàÎèÑÎ°ù Íµ¨ÏÑ±ÎêòÏóàÏäµÎãàÎã§.

## üìö ÌïôÏäµ ÏàúÏÑú

### 1. asyncio Í∏∞Ï¥à (`01_asyncio_basics.py`)

- ÎπÑÎèôÍ∏∞ ÌîÑÎ°úÍ∑∏ÎûòÎ∞çÏùò Í∏∞Î≥∏ Í∞úÎÖê
- ÏΩîÎ£®Ìã¥, Ïù¥Î≤§Ìä∏ Î£®ÌîÑ, Task Í∞ùÏ≤¥
- ÎèôÏãú Ïã§ÌñâÍ≥º ÏàúÏ∞® Ïã§ÌñâÏùò Ï∞®Ïù¥
- ÌÉÄÏûÑÏïÑÏõÉÍ≥º ÏûëÏóÖ Ï∑®ÏÜå

### 2. ÏõπÏÜåÏºì Í∏∞Ï¥à (`02_websocket_basics.py`)

- ÏõπÏÜåÏºì ÏÑúÎ≤ÑÏôÄ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Íµ¨ÌòÑ
- Î©îÏãúÏßÄ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
- Ïó∞Í≤∞ Í¥ÄÎ¶¨ÏôÄ Ïò§Î•ò Ï≤òÎ¶¨
- JSON Î©îÏãúÏßÄ Ï≤òÎ¶¨

### 3. Ïã§ÏãúÍ∞Ñ Ï±ÑÌåÖ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò (`03_realtime_chat.py`)

- asyncioÏôÄ ÏõπÏÜåÏºìÏùÑ Í≤∞Ìï©Ìïú Ïã§Ï†Ñ ÏòàÏ†ú
- ÏÇ¨Ïö©Ïûê Í¥ÄÎ¶¨ÏôÄ Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨
- ÌïòÌä∏ÎπÑÌä∏ Î™®ÎãàÌÑ∞ÎßÅ
- ÎåÄÌôîÌòï ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏

### 4. Í≥†Í∏â ÏõπÏÜåÏºì Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò (`04_advanced_websocket.py`)

- Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïä§Ìä∏Î¶¨Î∞ç
- Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ÏôÄ ÏßëÍ≥Ñ
- Ïù¥ÏÉÅÏπò ÌÉêÏßÄÏôÄ ÏûÑÍ≥ÑÍ∞í Î™®ÎãàÌÑ∞ÎßÅ
- ÏÑúÎ≤Ñ Î©îÌä∏Î¶≠Í≥º Î∂ÄÌïò Í¥ÄÎ¶¨

## üöÄ ÏÑ§Ïπò Î∞è Ïã§Ìñâ

### 1. ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò

```bash
pip install -r requirements.txt
```

### 2. ÏòàÏ†ú Ïã§Ìñâ

#### asyncio Í∏∞Ï¥à ÌïôÏäµ

```bash
python 01_asyncio_basics.py
```

#### ÏõπÏÜåÏºì Í∏∞Ï¥à ÌïôÏäµ

```bash
python 02_websocket_basics.py
```

#### Ïã§ÏãúÍ∞Ñ Ï±ÑÌåÖ (ÏÑúÎ≤Ñ)

```bash
python 03_realtime_chat.py
# ÏÑ†ÌÉù: 1 (ÏÑúÎ≤Ñ Ïã§Ìñâ)
```

#### Ïã§ÏãúÍ∞Ñ Ï±ÑÌåÖ (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏)

```bash
python 03_realtime_chat.py
# ÏÑ†ÌÉù: 2 (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïã§Ìñâ)
```

#### Í≥†Í∏â ÏõπÏÜåÏºì (ÏÑúÎ≤Ñ)

```bash
python 04_advanced_websocket.py
# ÏÑ†ÌÉù: 1 (ÏÑúÎ≤Ñ Ïã§Ìñâ)
```

#### Í≥†Í∏â ÏõπÏÜåÏºì (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏)

```bash
python 04_advanced_websocket.py
# ÏÑ†ÌÉù: 2 (Í∏∞Î≥∏ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏) ÎòêÎäî 3 (Î∂ÑÏÑù ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏)
```

## üìñ Ï£ºÏöî Í∞úÎÖê

### asyncio ÌïµÏã¨ Í∞úÎÖê

- **Coroutine**: `async def`Î°ú Ï†ïÏùòÎêú ÎπÑÎèôÍ∏∞ Ìï®Ïàò
- **Event Loop**: ÎπÑÎèôÍ∏∞ ÏûëÏóÖÎì§ÏùÑ Í¥ÄÎ¶¨ÌïòÎäî Î£®ÌîÑ
- **await**: Îã§Î•∏ ÏΩîÎ£®Ìã¥Ïùò ÏôÑÎ£åÎ•º Í∏∞Îã§Î¶º
- **Task**: Ïã§Ìñâ Ï§ëÏù∏ ÏΩîÎ£®Ìã¥ÏùÑ Í¥ÄÎ¶¨ÌïòÎäî Í∞ùÏ≤¥

### ÏõπÏÜåÏºì ÌïµÏã¨ Í∞úÎÖê

- **Handshake**: ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏôÄ ÏÑúÎ≤Ñ Í∞Ñ Ïó∞Í≤∞ ÏÑ§Ï†ï
- **Frame**: Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°Ïùò Í∏∞Î≥∏ Îã®ÏúÑ
- **Ping/Pong**: Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏ Î©îÏª§ÎãàÏ¶ò
- **Close**: Ïó∞Í≤∞ Ï¢ÖÎ£å ÌîÑÎ°úÏÑ∏Ïä§

### Ïã§Î¨¥ ÌôúÏö© Ìå®ÌÑ¥

- **Connection Pooling**: Ïó∞Í≤∞ Ïû¨ÏÇ¨Ïö©ÏúºÎ°ú ÏÑ±Îä• ÏµúÏ†ÅÌôî
- **Message Queuing**: Î©îÏãúÏßÄ ÏàúÏÑú Î≥¥Ïû•Í≥º Î∞∞Ïπò Ï≤òÎ¶¨
- **Load Balancing**: Ïó¨Îü¨ ÏÑúÎ≤Ñ Í∞Ñ Î∂ÄÌïò Î∂ÑÏÇ∞
- **Monitoring**: Ïã§ÏãúÍ∞Ñ Î©îÌä∏Î¶≠ ÏàòÏßëÍ≥º ÏïåÎ¶º

## üîß Í≥†Í∏â Í∏∞Îä•

### 1. Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïä§Ìä∏Î¶¨Î∞ç

- ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞, ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠, ÏÇ¨Ïö©Ïûê ÌôúÎèô Îì± Îã§ÏñëÌïú Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§
- Ïã§ÏãúÍ∞Ñ Ï≤òÎ¶¨ÏôÄ ÏßëÍ≥Ñ
- Ïù¥ÏÉÅÏπò ÌÉêÏßÄÏôÄ ÏûÑÍ≥ÑÍ∞í Î™®ÎãàÌÑ∞ÎßÅ

### 2. Ïó∞Í≤∞ Í¥ÄÎ¶¨

- ÏûêÎèô Ïû¨Ïó∞Í≤∞
- ÌïòÌä∏ÎπÑÌä∏ Î™®ÎãàÌÑ∞ÎßÅ
- Ïó∞Í≤∞ ÌíÄ Í¥ÄÎ¶¨

### 3. ÏÑ±Îä• ÏµúÏ†ÅÌôî

- ÎπÑÎèôÍ∏∞ I/O ÌôúÏö©
- Î©îÏãúÏßÄ Î∞∞Ïπò Ï≤òÎ¶¨
- Î©îÎ™®Î¶¨ Ìö®Ïú®Ï†ÅÏù∏ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞

### 4. Ïò§Î•ò Ï≤òÎ¶¨

- Ïó∞Í≤∞ ÎÅäÍπÄ Í∞êÏßÄ
- ÏûêÎèô Ïû¨ÏãúÎèÑ
- Ïö∞ÏïÑÌïú ÏÑúÎπÑÏä§ Ï§ëÎã®

## üéØ Ïã§Î¨¥ Ï†ÅÏö© ÏÇ¨Î°Ä

### 1. Ïã§ÏãúÍ∞Ñ Ï±ÑÌåÖ ÏãúÏä§ÌÖú

- Îã§Ï§ë ÏÇ¨Ïö©Ïûê ÏßÄÏõê
- Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨
- ÏÇ¨Ïö©Ïûê ÏÉÅÌÉú Í¥ÄÎ¶¨

### 2. IoT Îç∞Ïù¥ÌÑ∞ ÏàòÏßë

- ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ïã§ÏãúÍ∞Ñ ÏàòÏßë
- Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤òÎ¶¨ÏôÄ ÌïÑÌÑ∞ÎßÅ
- Ïù¥ÏÉÅ ÏÉÅÌô© ÏïåÎ¶º

### 3. Í∏àÏúµ Îç∞Ïù¥ÌÑ∞ Ïä§Ìä∏Î¶¨Î∞ç

- Ïã§ÏãúÍ∞Ñ ÏãúÏû• Îç∞Ïù¥ÌÑ∞
- Í≥†ÎπàÎèÑ Í±∞Îûò Ï≤òÎ¶¨
- ÏúÑÌóò Í¥ÄÎ¶¨

### 4. ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ÎßÅ

- ÏÑúÎ≤Ñ ÏÑ±Îä• Î©îÌä∏Î¶≠
- Î°úÍ∑∏ Ïä§Ìä∏Î¶¨Î∞ç
- ÏïåÎ¶º ÏãúÏä§ÌÖú

## üìù ÌïôÏäµ ÌåÅ

1. **Îã®Í≥ÑÎ≥Ñ ÌïôÏäµ**: Í∞Å ÌååÏùºÏùÑ ÏàúÏÑúÎåÄÎ°ú Ïã§ÌñâÌï¥Î≥¥ÏÑ∏Ïöî
2. **ÏΩîÎìú ÏàòÏ†ï**: ÏòàÏ†ú ÏΩîÎìúÎ•º ÏàòÏ†ïÌïòÎ©∞ Ïã§ÌóòÌï¥Î≥¥ÏÑ∏Ïöî
3. **ÎîîÎ≤ÑÍπÖ**: Î°úÍ∑∏Î•º ÌÜµÌï¥ ÎπÑÎèôÍ∏∞ ÏûëÏóÖÏùò ÌùêÎ¶ÑÏùÑ ÌååÏïÖÌïòÏÑ∏Ïöî
4. **ÏÑ±Îä• Ï∏°Ï†ï**: ÏãúÍ∞Ñ Ï∏°Ï†ïÏùÑ ÌÜµÌï¥ ÎèôÍ∏∞/ÎπÑÎèôÍ∏∞Ïùò Ï∞®Ïù¥Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî

## üêõ Î¨∏Ï†ú Ìï¥Í≤∞

### ÏùºÎ∞òÏ†ÅÏù∏ Î¨∏Ï†úÎì§

1. **ImportError: No module named 'websockets'**

   ```bash
   pip install websockets
   ```

2. **Ïó∞Í≤∞ Í±∞Î∂Ä Ïò§Î•ò**

   - ÏÑúÎ≤ÑÍ∞Ä Ïã§Ìñâ Ï§ëÏù∏ÏßÄ ÌôïÏù∏
   - Ìè¨Ìä∏ Î≤àÌò∏Í∞Ä Ïò¨Î∞îÎ•∏ÏßÄ ÌôïÏù∏

3. **Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Ï¶ùÍ∞Ä**
   - Ïó∞Í≤∞Ïù¥ Ï†úÎåÄÎ°ú Ìï¥Ï†úÎêòÎäîÏßÄ ÌôïÏù∏
   - Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ ÌÅ¨Í∏∞ Ï†úÌïú

## üìö Ï∂îÍ∞Ä ÌïôÏäµ ÏûêÎ£å

- [Python asyncio Í≥µÏãù Î¨∏ÏÑú](https://docs.python.org/3/library/asyncio.html)
- [WebSocket RFC 6455](https://tools.ietf.org/html/rfc6455)
- [websockets ÎùºÏù¥Î∏åÎü¨Î¶¨ Î¨∏ÏÑú](https://websockets.readthedocs.io/)

## ü§ù Í∏∞Ïó¨ÌïòÍ∏∞

Ïù¥ ÌîÑÎ°úÏ†ùÌä∏Ïóê Í∏∞Ïó¨ÌïòÍ≥† Ïã∂ÏúºÏãúÎã§Î©¥:

1. Ïù¥ÏäàÎ•º ÏÉùÏÑ±ÌïòÏó¨ Í∞úÏÑ† ÏÇ¨Ìï≠ÏùÑ Ï†úÏïàÌïòÏÑ∏Ïöî
2. ÌíÄ Î¶¨ÌÄòÏä§Ìä∏Î•º ÌÜµÌï¥ ÏΩîÎìú Í∞úÏÑ†ÏùÑ Ï†úÏïàÌïòÏÑ∏Ïöî
3. ÏÉàÎ°úÏö¥ ÏòàÏ†úÎÇò ÏÇ¨Ïö© ÏÇ¨Î°ÄÎ•º Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî

---

**Happy Coding! üöÄ**
</file>

<file path="requirements.txt">
websockets>=11.0.0
asyncio
</file>

<file path="simple_websocket_test.py">
#!/usr/bin/env python3
"""
Í∞ÑÎã®Ìïú ÏõπÏÜåÏºì ÏÑúÎ≤Ñ ÌÖåÏä§Ìä∏
"""
import asyncio
import websockets
import json
from datetime import datetime


class SimpleWebSocketServer:
    def __init__(self):
        self.clients = set()

    async def handle_client(self, websocket):
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï≤òÎ¶¨"""
        self.clients.add(websocket)
        print(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞: {websocket.remote_address}")

        try:
            async for message in websocket:
                print(f"Î∞õÏùÄ Î©îÏãúÏßÄ: {message}")

                try:
                    data = json.loads(message)
                    if data.get("type") == "ping":
                        response = {
                            "type": "pong",
                            "timestamp": datetime.now().isoformat(),
                        }
                        await websocket.send(json.dumps(response))
                    else:
                        await websocket.send(f"ÏóêÏΩî: {message}")
                except json.JSONDecodeError:
                    await websocket.send(f"ÏóêÏΩî: {message}")

        except websockets.exceptions.ConnectionClosed:
            print("ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï¢ÖÎ£å")
        finally:
            self.clients.discard(websocket)

    async def start_server(self):
        """ÏÑúÎ≤Ñ ÏãúÏûë"""
        print("ÏõπÏÜåÏºì ÏÑúÎ≤Ñ ÏãúÏûë: ws://localhost:8765")

        async with websockets.serve(self.handle_client, "localhost", 8765):
            print("ÏÑúÎ≤Ñ Ïã§Ìñâ Ï§ë...")
            await asyncio.Future()  # Î¨¥Ìïú ÎåÄÍ∏∞


async def test_client():
    """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌÖåÏä§Ìä∏"""
    await asyncio.sleep(1)  # ÏÑúÎ≤Ñ ÏãúÏûë ÎåÄÍ∏∞

    try:
        async with websockets.connect("ws://localhost:8765") as websocket:
            print("‚úÖ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ ÏÑ±Í≥µ")

            # ÌÖçÏä§Ìä∏ Î©îÏãúÏßÄ
            await websocket.send("Hello!")
            response = await websocket.recv()
            print(f"ÏùëÎãµ: {response}")

            # JSON Î©îÏãúÏßÄ
            await websocket.send(json.dumps({"type": "ping"}))
            response = await websocket.recv()
            print(f"Ìïë ÏùëÎãµ: {response}")

            print("‚úÖ ÌÖåÏä§Ìä∏ ÏôÑÎ£å")

    except Exception as e:
        print(f"‚ùå ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïò§Î•ò: {e}")


async def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    server = SimpleWebSocketServer()

    # ÏÑúÎ≤ÑÏôÄ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º ÎèôÏãúÏóê Ïã§Ìñâ
    server_task = asyncio.create_task(server.start_server())
    client_task = asyncio.create_task(test_client())

    # ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌÖåÏä§Ìä∏ ÏôÑÎ£å ÌõÑ ÏÑúÎ≤Ñ Ï¢ÖÎ£å
    await client_task
    server_task.cancel()

    try:
        await server_task
    except asyncio.CancelledError:
        pass

    print("ÌÖåÏä§Ìä∏ ÏôÑÎ£å!")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="test_websocket.py">
#!/usr/bin/env python3
"""
ÏõπÏÜåÏºì ÏÑúÎ≤Ñ ÌÖåÏä§Ìä∏
"""
import asyncio
import websockets
import json


async def test_websocket():
    """ÏõπÏÜåÏºì ÏÑúÎ≤Ñ ÌÖåÏä§Ìä∏"""
    try:
        # ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞
        uri = "ws://localhost:8765"
        async with websockets.connect(uri) as websocket:
            print("‚úÖ ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÑ±Í≥µ")

            # ÌÖçÏä§Ìä∏ Î©îÏãúÏßÄ Ï†ÑÏÜ°
            await websocket.send("Hello Server!")
            response = await websocket.recv()
            print(f"ÏÑúÎ≤Ñ ÏùëÎãµ: {response}")

            # JSON Î©îÏãúÏßÄ Ï†ÑÏÜ°
            ping_data = {"type": "ping"}
            await websocket.send(json.dumps(ping_data))
            response = await websocket.recv()
            print(f"Ìïë ÏùëÎãµ: {response}")

            print("‚úÖ ÏõπÏÜåÏºì ÌÖåÏä§Ìä∏ ÏôÑÎ£å")

    except Exception as e:
        print(f"‚ùå ÌÖåÏä§Ìä∏ Ïã§Ìå®: {e}")


if __name__ == "__main__":
    asyncio.run(test_websocket())
</file>

</files>
