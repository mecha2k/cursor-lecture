This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    code-quality.mdc
    performance.mdc
    python-core.mdc
    security.mdc
    testing.mdc
01_asyncio_basics.py
02_websocket_basics.py
03_realtime_chat.py
04_advanced_websocket.py
package.json
quick_websocket_test.py
README.md
requirements.txt
simple_websocket_test.py
test_websocket.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/code-quality.mdc">
---
globs: *.py
description: Code quality and style enforcement rules for Python
---

# Python Code Quality & Style Rules

## ğŸ¯ STYLE ENFORCEMENT - MANDATORY

### **PEP 8 Compliance - ZERO TOLERANCE**

- **ALWAYS** use 4 spaces for indentation (never tabs)
- **ALWAYS** limit lines to 88 characters (Black formatter standard)
- **ALWAYS** use snake_case for variables and functions
- **ALWAYS** use PascalCase for classes
- **ALWAYS** use UPPER_CASE for constants
- **NEVER** use trailing commas in single-line structures
- **NEVER** use spaces around `=` in function parameters

### **Import Organization - STRICT ORDER**

```python
# 1. Standard library imports (alphabetical)
import json
import os
import sys
from typing import Any, Dict, List, Optional

# 2. Third-party imports (alphabetical)
import pandas as pd
import requests
from django.conf import settings

# 3. Local application imports (alphabetical)
from .models import User
from .utils import format_data
from ..core.exceptions import ValidationError
```

## ğŸš¨ CRITICAL QUALITY GATES

### **MANDATORY: Function Design**

- **ALWAYS** keep functions under 20 lines
- **ALWAYS** use single responsibility principle
- **ALWAYS** return early to reduce nesting
- **NEVER** use more than 4 parameters (use dataclasses for complex data)
- **NEVER** use global variables inside functions

### **MANDATORY: Class Design**

- **ALWAYS** use `__slots__` for classes with many instances
- **ALWAYS** implement `__repr__` and `__str__` methods
- **ALWAYS** use properties for computed attributes
- **NEVER** use inheritance for code reuse (prefer composition)
- **NEVER** use more than 3 levels of inheritance

### **MANDATORY: Error Handling**

```python
# âœ… CORRECT - Specific exception handling
try:
    result = risky_operation()
except SpecificError as e:
    logger.error(f"Operation failed: {e}")
    return None
except AnotherError as e:
    logger.warning(f"Non-critical failure: {e}")
    return default_value

# âŒ WRONG - Bare except
try:
    result = risky_operation()
except:  # NEVER DO THIS
    pass
```

## ğŸ”§ CODE PATTERNS - ENFORCED

### **String Handling**

```python
# âœ… CORRECT - f-strings for formatting
name = "John"
message = f"Hello, {name}!"

# âœ… CORRECT - join() for concatenation
words = ["hello", "world", "python"]
sentence = " ".join(words)

# âŒ WRONG - String concatenation in loops
result = ""
for word in words:
    result += word + " "  # Inefficient!
```

### **List and Dictionary Operations**

```python
# âœ… CORRECT - List comprehensions
squares = [x**2 for x in range(10) if x % 2 == 0]

# âœ… CORRECT - Dictionary comprehensions
user_ages = {user.name: user.age for user in users if user.age > 18}

# âœ… CORRECT - Generator expressions for large datasets
large_sum = sum(x**2 for x in range(1000000))

# âŒ WRONG - Unnecessary list creation
large_sum = sum([x**2 for x in range(1000000)])  # Creates unnecessary list
```

### **Context Managers - MANDATORY**

```python
# âœ… CORRECT - Always use context managers
with open('file.txt', 'r') as f:
    content = f.read()

# âœ… CORRECT - Custom context managers
from contextlib import contextmanager

@contextmanager
def database_connection():
    conn = get_connection()
    try:
        yield conn
    finally:
        conn.close()

# âŒ WRONG - Manual resource management
f = open('file.txt', 'r')
content = f.read()
f.close()  # May not execute if exception occurs
```

## ğŸš« ABSOLUTE PROHIBITIONS

### **NEVER USE THESE PATTERNS:**

- âŒ `eval()` or `exec()` with any user input
- âŒ `globals()` or `locals()` for variable access
- âŒ `import *` in any module
- âŒ Mutable default arguments: `def func(items=[]):`
- âŒ Bare `except:` clauses
- âŒ `==` for None comparison (use `is None`)
- âŒ `print()` for logging (use proper logging)
- âŒ Global variables for state management

### **ANTI-PATTERNS TO AVOID:**

```python
# âŒ WRONG - Mutable default argument
def add_item(item, items=[]):
    items.append(item)
    return items

# âœ… CORRECT - Use None as default
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items

# âŒ WRONG - String concatenation in loop
result = ""
for item in items:
    result += str(item)

# âœ… CORRECT - Use join()
result = "".join(str(item) for item in items)
```

## ğŸ“Š PERFORMANCE REQUIREMENTS

### **Memory Efficiency**

- Use generators for large datasets
- Implement `__slots__` for classes with many instances
- Use `collections.namedtuple` for simple data structures
- Prefer `pathlib.Path` over `os.path`

### **CPU Efficiency**

- Use list comprehensions over explicit loops
- Prefer `enumerate()` over manual indexing
- Use `collections.defaultdict` for counting
- Cache expensive computations with `functools.lru_cache`

### **I/O Efficiency**

- Use async/await for I/O-bound operations
- Batch database operations
- Use connection pooling
- Implement proper caching strategies

## ğŸ§ª TESTING REQUIREMENTS

### **Test Structure**

```python
import pytest
from unittest.mock import Mock, patch

class TestUserService:
    """Test suite for UserService class."""

    def setup_method(self):
        """Set up test fixtures before each test method."""
        self.user_service = UserService()
        self.mock_user = Mock()

    def test_create_user_success(self):
        """Test successful user creation."""
        # Arrange
        user_data = {"name": "John", "email": "john@example.com"}

        # Act
        result = self.user_service.create_user(user_data)

        # Assert
        assert result.name == "John"
        assert result.email == "john@example.com"

    def test_create_user_invalid_email(self):
        """Test user creation with invalid email."""
        # Arrange
        user_data = {"name": "John", "email": "invalid-email"}

        # Act & Assert
        with pytest.raises(ValidationError):
            self.user_service.create_user(user_data)
```

### **Test Coverage Requirements**

- **MANDATORY**: >90% code coverage
- **MANDATORY**: Test all public methods
- **MANDATORY**: Test both success and failure scenarios
- **MANDATORY**: Mock all external dependencies
- **MANDATORY**: Test edge cases and boundary conditions

## ğŸ” CODE REVIEW CHECKLIST

### **Before Submitting Code:**

- [ ] All functions have type hints
- [ ] All public functions have docstrings
- [ ] Code follows PEP 8 (run `black` and `flake8`)
- [ ] No bare `except:` clauses
- [ ] All imports are organized correctly
- [ ] No hardcoded secrets or credentials
- [ ] Proper error handling for all external calls
- [ ] Unit tests cover all new functionality
- [ ] No performance anti-patterns
- [ ] Memory usage is optimized for large datasets
</file>

<file path=".cursor/rules/performance.mdc">
---
globs: *.py
description: Performance optimization rules for Python development
---

# Python Performance Rules

## ğŸš€ CRITICAL PERFORMANCE REQUIREMENTS

### **MEMORY EFFICIENCY - MANDATORY**

- **ALWAYS** use generators for large datasets instead of lists
- **ALWAYS** implement `__slots__` for classes with many instances
- **ALWAYS** use `collections.namedtuple` for simple data structures
- **NEVER** load entire files into memory if processing line by line
- **NEVER** create unnecessary intermediate lists

### **CPU EFFICIENCY - MANDATORY**

- **ALWAYS** use list comprehensions over explicit loops when appropriate
- **ALWAYS** prefer `enumerate()` over manual indexing
- **ALWAYS** use `collections.defaultdict` for counting operations
- **ALWAYS** cache expensive computations with `functools.lru_cache`
- **NEVER** use string concatenation in loops

### **I/O EFFICIENCY - MANDATORY**

- **ALWAYS** use async/await for I/O-bound operations
- **ALWAYS** batch database operations
- **ALWAYS** use connection pooling
- **NEVER** make synchronous calls in async functions
- **NEVER** open/close connections in loops

## âš¡ PERFORMANCE PATTERNS - ENFORCED

### **Memory Optimization**

```python
# âœ… CORRECT - Generator for large datasets
def process_large_file(filename: str) -> Generator[str, None, None]:
    """Process large file line by line without loading into memory."""
    with open(filename, 'r') as f:
        for line in f:
            yield process_line(line)

# âœ… CORRECT - Using __slots__ for memory efficiency
class Point:
    __slots__ = ['x', 'y', 'z']

    def __init__(self, x: float, y: float, z: float):
        self.x = x
        self.y = y
        self.z = z

# âœ… CORRECT - Namedtuple for simple data
from collections import namedtuple
User = namedtuple('User', ['id', 'name', 'email'])

# âŒ WRONG - Loading entire file into memory
def process_large_file_wrong(filename: str) -> List[str]:
    with open(filename, 'r') as f:
        lines = f.readlines()  # Loads entire file into memory
    return [process_line(line) for line in lines]
```

### **CPU Optimization**

```python
# âœ… CORRECT - List comprehension
squares = [x**2 for x in range(1000) if x % 2 == 0]

# âœ… CORRECT - Generator expression for large datasets
large_sum = sum(x**2 for x in range(1000000))

# âœ… CORRECT - Using enumerate
for i, item in enumerate(items):
    process_item(i, item)

# âœ… CORRECT - Using defaultdict for counting
from collections import defaultdict
word_count = defaultdict(int)
for word in words:
    word_count[word] += 1

# âŒ WRONG - Inefficient string concatenation
result = ""
for word in words:
    result += word + " "  # Creates new string each time

# âœ… CORRECT - Using join()
result = " ".join(words)
```

### **Caching and Memoization**

```python
from functools import lru_cache, wraps
from typing import Callable, Any
import time

# âœ… CORRECT - LRU cache for expensive computations
@lru_cache(maxsize=128)
def fibonacci(n: int) -> int:
    """Calculate Fibonacci number with caching."""
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# âœ… CORRECT - Custom caching decorator
def cache_result(func: Callable) -> Callable:
    """Cache function results based on arguments."""
    cache = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
        key = str(args) + str(sorted(kwargs.items()))
        if key not in cache:
            cache[key] = func(*args, **kwargs)
        return cache[key]

    return wrapper

@cache_result
def expensive_calculation(data: List[int]) -> float:
    """Expensive calculation that benefits from caching."""
    time.sleep(1)  # Simulate expensive operation
    return sum(x**2 for x in data) / len(data)
```

## ğŸ”„ ASYNC/AWAIT PATTERNS

### **Proper Async Implementation**

```python
import asyncio
import aiohttp
from typing import List, Dict, Any

# âœ… CORRECT - Async function for I/O operations
async def fetch_data(url: str) -> Dict[str, Any]:
    """Fetch data asynchronously."""
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.json()

# âœ… CORRECT - Batch async operations
async def fetch_multiple_urls(urls: List[str]) -> List[Dict[str, Any]]:
    """Fetch multiple URLs concurrently."""
    tasks = [fetch_data(url) for url in urls]
    return await asyncio.gather(*tasks)

# âœ… CORRECT - Async context manager
class AsyncDatabaseConnection:
    async def __aenter__(self):
        self.conn = await get_async_connection()
        return self.conn

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.conn.close()

# âŒ WRONG - Blocking operations in async function
async def bad_async_function():
    # This blocks the event loop
    result = requests.get('https://api.example.com')  # Synchronous call
    return result.json()
```

### **Database Optimization**

```python
import asyncio
from typing import List, Dict, Any

# âœ… CORRECT - Batch database operations
async def batch_insert_users(users: List[Dict[str, Any]]) -> None:
    """Insert multiple users in a single transaction."""
    async with get_async_connection() as conn:
        async with conn.transaction():
            await conn.executemany(
                "INSERT INTO users (name, email) VALUES ($1, $2)",
                [(user['name'], user['email']) for user in users]
            )

# âœ… CORRECT - Connection pooling
class DatabasePool:
    def __init__(self, max_connections: int = 10):
        self.semaphore = asyncio.Semaphore(max_connections)
        self.connections = []

    async def get_connection(self):
        await self.semaphore.acquire()
        if self.connections:
            return self.connections.pop()
        return await create_connection()

    async def return_connection(self, conn):
        self.connections.append(conn)
        self.semaphore.release()
```

## ğŸ“Š PROFILING AND MONITORING

### **Performance Monitoring**

```python
import time
import functools
from typing import Callable, Any
import logging

def profile_function(func: Callable) -> Callable:
    """Decorator to profile function execution time."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()

        execution_time = end_time - start_time
        logging.info(f"{func.__name__} executed in {execution_time:.4f} seconds")

        return result
    return wrapper

@profile_function
def process_large_dataset(data: List[int]) -> List[int]:
    """Process large dataset with performance monitoring."""
    return [x**2 for x in data if x % 2 == 0]

# Memory profiling
import tracemalloc

def profile_memory(func: Callable) -> Callable:
    """Decorator to profile memory usage."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        tracemalloc.start()
        result = func(*args, **kwargs)
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()

        logging.info(f"Memory usage - Current: {current / 1024 / 1024:.2f} MB, Peak: {peak / 1024 / 1024:.2f} MB")
        return result
    return wrapper
```

## ğŸš« PERFORMANCE ANTI-PATTERNS

### **NEVER USE THESE PATTERNS:**

- âŒ String concatenation in loops
- âŒ Loading entire files into memory unnecessarily
- âŒ Creating large intermediate lists
- âŒ Using synchronous I/O in async functions
- âŒ Opening/closing connections in loops
- âŒ Using `global` variables for caching
- âŒ Recursive functions without memoization
- âŒ Nested loops when alternatives exist

### **COMMON PERFORMANCE MISTAKES:**

```python
# âŒ WRONG - Inefficient string building
def build_string_wrong(items: List[str]) -> str:
    result = ""
    for item in items:
        result += item + ", "  # Creates new string each time
    return result

# âœ… CORRECT - Efficient string building
def build_string_correct(items: List[str]) -> str:
    return ", ".join(items)

# âŒ WRONG - Inefficient list creation
def process_data_wrong(data: List[int]) -> List[int]:
    result = []
    for item in data:
        if item % 2 == 0:
            result.append(item * 2)
    return result

# âœ… CORRECT - List comprehension
def process_data_correct(data: List[int]) -> List[int]:
    return [item * 2 for item in data if item % 2 == 0]

# âŒ WRONG - Synchronous I/O in async function
async def bad_async_io():
    with open('file.txt', 'r') as f:  # Blocking I/O
        return f.read()

# âœ… CORRECT - Async I/O
async def good_async_io():
    async with aiofiles.open('file.txt', 'r') as f:
        return await f.read()
```

## ğŸ¯ PERFORMANCE TARGETS

### **Response Time Requirements:**

- API endpoints: < 200ms for 95th percentile
- Database queries: < 100ms for simple queries
- File I/O operations: < 50ms for files < 1MB
- Memory usage: < 100MB for typical operations

### **Scalability Requirements:**

- Support 1000+ concurrent users
- Handle 10,000+ requests per minute
- Process files up to 1GB efficiently
- Maintain < 1% error rate under load

## ğŸ“‹ PERFORMANCE CHECKLIST

### **Before Every Deployment:**

- [ ] All I/O operations are async where possible
- [ ] Large datasets use generators, not lists
- [ ] Database queries are optimized and batched
- [ ] Expensive computations are cached
- [ ] Memory usage is monitored and optimized
- [ ] No blocking operations in async functions
- [ ] Connection pooling is implemented
- [ ] Performance tests pass
- [ ] Memory leaks are prevented
- [ ] CPU usage is optimized
</file>

<file path=".cursor/rules/python-core.mdc">
---
alwaysApply: true
description: Core Python development rules and best practices
---

# Python Core Development Rules

## ğŸš¨ CRITICAL REQUIREMENTS - NEVER VIOLATE

### **MANDATORY: Type Safety & Error Handling**

- **ALWAYS** use type hints for function parameters, return types, and class attributes
- **ALWAYS** handle exceptions with specific exception types, never bare `except:`
- **ALWAYS** use `typing.Optional` for nullable values, never `None` without explicit typing
- **NEVER** use `Any` type unless absolutely necessary - prefer specific types
- **NEVER** ignore exceptions silently - always log or handle appropriately

### **MANDATORY: Code Structure**

- **ALWAYS** follow PEP 8 style guidelines strictly
- **ALWAYS** use meaningful variable and function names (minimum 3 characters)
- **ALWAYS** write docstrings for all public functions, classes, and modules
- **NEVER** use single-letter variable names except for loop counters (i, j, k)
- **NEVER** exceed 88 characters per line (use Black formatter standard)

### **MANDATORY: Import Organization**

```python
# Standard library imports
import os
import sys
from typing import List, Dict, Optional

# Third-party imports
import requests
import pandas as pd

# Local imports
from .models import User
from .utils import validate_input
```

## ğŸ¯ OPTIMIZATION TECHNIQUES

### **Performance Critical Patterns**

- Use list comprehensions over explicit loops when appropriate
- Prefer `enumerate()` over manual indexing
- Use `collections.defaultdict` for counting operations
- Cache expensive computations with `functools.lru_cache`

### **Memory Management**

- Use generators for large datasets instead of lists
- Implement `__slots__` for classes with many instances
- Use context managers (`with` statements) for resource management
- Prefer `pathlib.Path` over `os.path` for file operations

### **Modern Python Features (3.8+)**

- Use f-strings for string formatting
- Leverage dataclasses for simple data containers
- Use walrus operator (`:=`) judiciously for assignment expressions
- Prefer `typing.Union` over `typing.Optional` for explicit union types

## ğŸš« ABSOLUTE PROHIBITIONS

### **NEVER DO THESE:**

- âŒ Use mutable default arguments: `def func(items=[]):`
- âŒ Use `==` to compare with `None` (use `is None` instead)
- âŒ Use `eval()` or `exec()` with user input
- âŒ Use bare `except:` clauses
- âŒ Use `import *` in production code
- âŒ Use global variables for state management
- âŒ Use `print()` for logging (use proper logging)
- âŒ Use string concatenation in loops (use `join()`)

### **SECURITY VIOLATIONS:**

- âŒ Never use `pickle` with untrusted data
- âŒ Never use `subprocess` with shell=True and user input
- âŒ Never store secrets in code (use environment variables)
- âŒ Never use weak random number generators for security

## ğŸ“‹ CODE QUALITY CHECKLIST

### **Before Every Commit:**

- [ ] All functions have type hints
- [ ] All public functions have docstrings
- [ ] No bare `except:` clauses
- [ ] All imports are organized correctly
- [ ] Code follows PEP 8 (run `black` and `flake8`)
- [ ] No hardcoded secrets or credentials
- [ ] Proper error handling for all external calls

### **Function Design Pattern:**

```python
def process_user_data(
    user_id: int,
    data: Dict[str, Any],
    validate: bool = True
) -> Optional[ProcessedData]:
    """
    Process user data with optional validation.

    Args:
        user_id: Unique identifier for the user
        data: Raw user data dictionary
        validate: Whether to validate data before processing

    Returns:
        ProcessedData object if successful, None if validation fails

    Raises:
        ValueError: If user_id is invalid
        DataValidationError: If data validation fails
    """
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError(f"Invalid user_id: {user_id}")

    try:
        if validate:
            validated_data = validate_user_data(data)
        else:
            validated_data = data

        return ProcessedData.from_dict(validated_data)
    except ValidationError as e:
        logger.error(f"Data validation failed: {e}")
        return None
```

## ğŸ”§ DEVELOPMENT WORKFLOW

### **File Organization:**

- Keep related functionality in the same module
- Use `__init__.py` files to control package imports
- Separate configuration from business logic
- Use dependency injection for testability

### **Error Handling Strategy:**

1. **Fail Fast**: Validate inputs at function boundaries
2. **Specific Exceptions**: Create custom exception classes for business logic
3. **Graceful Degradation**: Handle external service failures gracefully
4. **Logging**: Log all errors with appropriate levels and context

### **Testing Requirements:**

- Write unit tests for all public functions
- Use pytest fixtures for test setup
- Mock external dependencies
- Aim for >90% code coverage
- Test both success and failure scenarios
</file>

<file path=".cursor/rules/security.mdc">
---
globs: *.py
description: Security-focused rules for Python development
---

# Python Security Rules

## ğŸš¨ CRITICAL SECURITY REQUIREMENTS - ZERO TOLERANCE

### **INPUT VALIDATION - MANDATORY**

- **ALWAYS** validate all user inputs at application boundaries
- **ALWAYS** use allowlists instead of blocklists for validation
- **ALWAYS** sanitize data before database operations
- **NEVER** trust user input without validation
- **NEVER** use `eval()` or `exec()` with user data

### **AUTHENTICATION & AUTHORIZATION**

- **ALWAYS** use secure password hashing (bcrypt, scrypt, or Argon2)
- **ALWAYS** implement proper session management
- **ALWAYS** validate JWT tokens and check expiration
- **NEVER** store passwords in plain text
- **NEVER** use weak random number generators for security

### **SECRETS MANAGEMENT**

- **ALWAYS** use environment variables for secrets
- **ALWAYS** use proper secret management systems in production
- **NEVER** hardcode secrets, API keys, or passwords in code
- **NEVER** commit secrets to version control

## ğŸ”’ SECURITY PATTERNS - ENFORCED

### **Safe Input Handling**

```python
import re
from typing import Optional

def validate_email(email: str) -> bool:
    """Validate email format using regex."""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))

def sanitize_filename(filename: str) -> str:
    """Sanitize filename to prevent path traversal."""
    # Remove dangerous characters
    safe_filename = re.sub(r'[^\w\-_\.]', '', filename)
    # Prevent path traversal
    safe_filename = safe_filename.replace('..', '')
    return safe_filename

# âœ… CORRECT - Input validation
def process_user_input(user_input: str) -> Optional[str]:
    if not isinstance(user_input, str):
        raise ValueError("Input must be a string")

    if len(user_input) > 1000:
        raise ValueError("Input too long")

    # Sanitize and validate
    sanitized = sanitize_filename(user_input)
    return sanitized if sanitized else None
```

### **Secure Password Handling**

```python
import bcrypt
import secrets
from typing import Tuple

def hash_password(password: str) -> str:
    """Hash password using bcrypt."""
    if not isinstance(password, str):
        raise ValueError("Password must be a string")

    if len(password) < 8:
        raise ValueError("Password must be at least 8 characters")

    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def verify_password(password: str, hashed: str) -> bool:
    """Verify password against hash."""
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

def generate_secure_token() -> str:
    """Generate cryptographically secure token."""
    return secrets.token_urlsafe(32)
```

### **Safe Database Operations**

```python
import sqlite3
from typing import List, Dict, Any

def get_user_by_id(user_id: int) -> Optional[Dict[str, Any]]:
    """Safely retrieve user by ID using parameterized queries."""
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError("Invalid user ID")

    conn = sqlite3.connect('database.db')
    try:
        # âœ… CORRECT - Parameterized query prevents SQL injection
        cursor = conn.execute(
            "SELECT * FROM users WHERE id = ?",
            (user_id,)
        )
        row = cursor.fetchone()
        return dict(zip([col[0] for col in cursor.description], row)) if row else None
    finally:
        conn.close()

# âŒ WRONG - SQL injection vulnerability
def get_user_by_id_unsafe(user_id: str) -> Dict[str, Any]:
    conn = sqlite3.connect('database.db')
    # NEVER DO THIS - SQL injection risk
    cursor = conn.execute(f"SELECT * FROM users WHERE id = {user_id}")
    return cursor.fetchone()
```

## ğŸš« CRITICAL SECURITY VIOLATIONS - NEVER ALLOW

### **ABSOLUTE PROHIBITIONS:**

- âŒ **NEVER** use `eval()` or `exec()` with user input
- âŒ **NEVER** use `pickle` with untrusted data
- âŒ **NEVER** use `subprocess` with `shell=True` and user input
- âŒ **NEVER** store secrets in code or configuration files
- âŒ **NEVER** use weak random number generators for security
- âŒ **NEVER** disable SSL/TLS certificate verification
- âŒ **NEVER** use hardcoded credentials or API keys

### **DANGEROUS PATTERNS:**

```python
# âŒ CRITICAL SECURITY VIOLATIONS - NEVER USE

# 1. Code injection
user_code = input("Enter code: ")
eval(user_code)  # NEVER DO THIS

# 2. Command injection
user_input = input("Enter filename: ")
os.system(f"cat {user_input}")  # NEVER DO THIS

# 3. Unsafe deserialization
import pickle
with open('data.pkl', 'rb') as f:
    data = pickle.load(f)  # NEVER DO THIS with untrusted data

# 4. Hardcoded secrets
API_KEY = "sk-1234567890abcdef"  # NEVER DO THIS
DATABASE_PASSWORD = "password123"  # NEVER DO THIS

# 5. Weak random for security
import random
token = str(random.randint(100000, 999999))  # NEVER DO THIS
```

## ğŸ” SECURE CODING PATTERNS

### **Environment Variables for Secrets**

```python
import os
from typing import Optional

def get_secret(secret_name: str, default: Optional[str] = None) -> str:
    """Safely retrieve secret from environment variables."""
    secret = os.getenv(secret_name, default)
    if not secret:
        raise ValueError(f"Secret {secret_name} not found in environment")
    return secret

# âœ… CORRECT - Use environment variables
DATABASE_URL = get_secret('DATABASE_URL')
API_KEY = get_secret('API_KEY')
JWT_SECRET = get_secret('JWT_SECRET')
```

### **Secure File Operations**

```python
import os
from pathlib import Path
from typing import Optional

def safe_file_read(file_path: str) -> Optional[str]:
    """Safely read file with path traversal protection."""
    path = Path(file_path)

    # Prevent path traversal
    if '..' in str(path) or path.is_absolute():
        raise ValueError("Invalid file path")

    # Check if file exists and is readable
    if not path.exists() or not path.is_file():
        raise FileNotFoundError("File not found")

    try:
        with open(path, 'r', encoding='utf-8') as f:
            return f.read()
    except UnicodeDecodeError:
        raise ValueError("File contains invalid characters")
```

### **Secure HTTP Requests**

```python
import requests
from typing import Dict, Any
import ssl

def secure_http_request(url: str, data: Dict[str, Any]) -> Dict[str, Any]:
    """Make secure HTTP request with proper validation."""
    # Validate URL
    if not url.startswith(('https://', 'http://')):
        raise ValueError("Invalid URL protocol")

    # Create session with secure settings
    session = requests.Session()
    session.verify = True  # Verify SSL certificates

    try:
        response = session.post(
            url,
            json=data,
            timeout=30,
            headers={'Content-Type': 'application/json'}
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.SSLError:
        raise ValueError("SSL certificate verification failed")
    except requests.exceptions.Timeout:
        raise ValueError("Request timeout")
```

## ğŸ›¡ï¸ SECURITY TESTING REQUIREMENTS

### **Security Test Cases**

```python
import pytest
from unittest.mock import patch

class TestSecurityFeatures:
    """Test security-related functionality."""

    def test_sql_injection_prevention(self):
        """Test that SQL injection attempts are prevented."""
        malicious_input = "1; DROP TABLE users; --"

        with pytest.raises(ValueError):
            get_user_by_id(malicious_input)

    def test_path_traversal_prevention(self):
        """Test that path traversal attempts are blocked."""
        malicious_path = "../../../etc/passwd"

        with pytest.raises(ValueError):
            safe_file_read(malicious_path)

    def test_input_validation(self):
        """Test that invalid inputs are rejected."""
        invalid_inputs = [
            None,
            "",
            "x" * 10000,  # Too long
            "<script>alert('xss')</script>",  # XSS attempt
        ]

        for invalid_input in invalid_inputs:
            with pytest.raises((ValueError, TypeError)):
                validate_email(invalid_input)
```

## ğŸ“‹ SECURITY CHECKLIST

### **Before Every Deployment:**

- [ ] No hardcoded secrets or credentials
- [ ] All user inputs are validated and sanitized
- [ ] SQL queries use parameterized statements
- [ ] Passwords are properly hashed
- [ ] SSL/TLS is properly configured
- [ ] Error messages don't leak sensitive information
- [ ] File operations are protected against path traversal
- [ ] All external requests use HTTPS
- [ ] Session management is secure
- [ ] Logging doesn't include sensitive data

### **Security Headers (for web applications):**

```python
# Add these headers to all HTTP responses
SECURITY_HEADERS = {
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Content-Security-Policy': "default-src 'self'",
}
```

## ğŸš¨ EMERGENCY SECURITY RESPONSE

### **If Security Issue is Discovered:**

1. **IMMEDIATELY** revoke compromised credentials
2. **IMMEDIATELY** patch the vulnerability
3. **IMMEDIATELY** rotate all secrets and keys
4. **IMMEDIATELY** audit logs for suspicious activity
5. **IMMEDIATELY** notify security team
6. **NEVER** ignore or delay security fixes
</file>

<file path=".cursor/rules/testing.mdc">
---
globs: test_*.py,*_test.py,conftest.py
description: Testing and documentation rules for Python development
---

# Python Testing & Documentation Rules

## ğŸ§ª CRITICAL TESTING REQUIREMENTS

### **TEST COVERAGE - MANDATORY**

- **ALWAYS** achieve >90% code coverage
- **ALWAYS** test all public functions and methods
- **ALWAYS** test both success and failure scenarios
- **ALWAYS** test edge cases and boundary conditions
- **NEVER** commit code without corresponding tests

### **TEST STRUCTURE - MANDATORY**

- **ALWAYS** use pytest as the testing framework
- **ALWAYS** organize tests in classes for related functionality
- **ALWAYS** use descriptive test method names
- **ALWAYS** follow AAA pattern (Arrange, Act, Assert)
- **NEVER** write tests that depend on external services

### **MOCKING - MANDATORY**

- **ALWAYS** mock external dependencies (APIs, databases, file system)
- **ALWAYS** use dependency injection for testability
- **ALWAYS** verify mock calls and arguments
- **NEVER** make real network calls in tests
- **NEVER** use real database connections in unit tests

## ğŸ“ DOCUMENTATION REQUIREMENTS

### **DOCSTRINGS - MANDATORY**

- **ALWAYS** write docstrings for all public functions, classes, and modules
- **ALWAYS** follow Google-style docstring format
- **ALWAYS** include parameter types, return types, and exceptions
- **ALWAYS** provide usage examples for complex functions
- **NEVER** leave public functions undocumented

### **CODE COMMENTS - MANDATORY**

- **ALWAYS** explain complex business logic
- **ALWAYS** document non-obvious performance optimizations
- **ALWAYS** explain why, not what
- **NEVER** comment obvious code
- **NEVER** leave TODO comments in production code

## ğŸ§ª TESTING PATTERNS - ENFORCED

### **Unit Test Structure**

```python
import pytest
from unittest.mock import Mock, patch, MagicMock
from typing import List, Dict, Any
import tempfile
import os

class TestUserService:
    """Test suite for UserService class."""

    def setup_method(self):
        """Set up test fixtures before each test method."""
        self.user_service = UserService()
        self.mock_user = Mock()
        self.mock_user.id = 1
        self.mock_user.name = "John Doe"
        self.mock_user.email = "john@example.com"

    def test_create_user_success(self):
        """Test successful user creation with valid data."""
        # Arrange
        user_data = {
            "name": "John Doe",
            "email": "john@example.com",
            "age": 30
        }
        expected_user = User(id=1, **user_data)

        with patch('app.services.user_service.UserRepository') as mock_repo:
            mock_repo.return_value.create.return_value = expected_user

            # Act
            result = self.user_service.create_user(user_data)

            # Assert
            assert result == expected_user
            mock_repo.return_value.create.assert_called_once_with(user_data)

    def test_create_user_invalid_email(self):
        """Test user creation fails with invalid email format."""
        # Arrange
        user_data = {
            "name": "John Doe",
            "email": "invalid-email-format",
            "age": 30
        }

        # Act & Assert
        with pytest.raises(ValidationError, match="Invalid email format"):
            self.user_service.create_user(user_data)

    def test_create_user_duplicate_email(self):
        """Test user creation fails when email already exists."""
        # Arrange
        user_data = {
            "name": "John Doe",
            "email": "existing@example.com",
            "age": 30
        }

        with patch('app.services.user_service.UserRepository') as mock_repo:
            mock_repo.return_value.find_by_email.return_value = self.mock_user

            # Act & Assert
            with pytest.raises(DuplicateEmailError):
                self.user_service.create_user(user_data)

    def test_get_user_by_id_success(self):
        """Test successful user retrieval by ID."""
        # Arrange
        user_id = 1

        with patch('app.services.user_service.UserRepository') as mock_repo:
            mock_repo.return_value.find_by_id.return_value = self.mock_user

            # Act
            result = self.user_service.get_user_by_id(user_id)

            # Assert
            assert result == self.mock_user
            mock_repo.return_value.find_by_id.assert_called_once_with(user_id)

    def test_get_user_by_id_not_found(self):
        """Test user retrieval returns None when user doesn't exist."""
        # Arrange
        user_id = 999

        with patch('app.services.user_service.UserRepository') as mock_repo:
            mock_repo.return_value.find_by_id.return_value = None

            # Act
            result = self.user_service.get_user_by_id(user_id)

            # Assert
            assert result is None
```

### **Integration Test Structure**

```python
import pytest
import asyncio
from httpx import AsyncClient
from app.main import app
from app.database import get_test_db

class TestUserAPI:
    """Integration tests for User API endpoints."""

    @pytest.fixture
    async def client(self):
        """Create test client with test database."""
        async with AsyncClient(app=app, base_url="http://test") as ac:
            yield ac

    @pytest.fixture
    async def test_user(self, client):
        """Create a test user for API tests."""
        user_data = {
            "name": "Test User",
            "email": "test@example.com",
            "age": 25
        }
        response = await client.post("/users", json=user_data)
        return response.json()

    async def test_create_user_endpoint(self, client):
        """Test POST /users endpoint."""
        # Arrange
        user_data = {
            "name": "New User",
            "email": "newuser@example.com",
            "age": 30
        }

        # Act
        response = await client.post("/users", json=user_data)

        # Assert
        assert response.status_code == 201
        data = response.json()
        assert data["name"] == user_data["name"]
        assert data["email"] == user_data["email"]
        assert "id" in data

    async def test_get_user_endpoint(self, client, test_user):
        """Test GET /users/{user_id} endpoint."""
        # Act
        response = await client.get(f"/users/{test_user['id']}")

        # Assert
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == test_user["id"]
        assert data["name"] == test_user["name"]

    async def test_get_user_not_found(self, client):
        """Test GET /users/{user_id} returns 404 for non-existent user."""
        # Act
        response = await client.get("/users/999")

        # Assert
        assert response.status_code == 404
```

### **Fixture Management**

```python
import pytest
from typing import Generator, AsyncGenerator
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.database import Base, get_db
from app.models import User

@pytest.fixture(scope="session")
def test_engine():
    """Create test database engine."""
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    return engine

@pytest.fixture
def test_db(test_engine):
    """Create test database session."""
    TestingSessionLocal = sessionmaker(bind=test_engine)
    session = TestingSessionLocal()
    try:
        yield session
    finally:
        session.close()

@pytest.fixture
def sample_user(test_db) -> User:
    """Create a sample user for testing."""
    user = User(
        name="Test User",
        email="test@example.com",
        age=25
    )
    test_db.add(user)
    test_db.commit()
    test_db.refresh(user)
    return user

@pytest.fixture
def multiple_users(test_db) -> List[User]:
    """Create multiple users for testing."""
    users = [
        User(name=f"User {i}", email=f"user{i}@example.com", age=20+i)
        for i in range(5)
    ]
    test_db.add_all(users)
    test_db.commit()
    return users
```

## ğŸ“š DOCUMENTATION PATTERNS

### **Function Documentation**

```python
def calculate_compound_interest(
    principal: float,
    rate: float,
    time: int,
    compounding_frequency: int = 12
) -> float:
    """
    Calculate compound interest for an investment.

    This function calculates the compound interest using the formula:
    A = P(1 + r/n)^(nt)
    where:
    - A = final amount
    - P = principal amount
    - r = annual interest rate
    - n = number of times interest is compounded per year
    - t = time in years

    Args:
        principal: The initial amount of money invested
        rate: Annual interest rate as a decimal (e.g., 0.05 for 5%)
        time: Time period in years
        compounding_frequency: Number of times interest is compounded per year

    Returns:
        The final amount after compound interest

    Raises:
        ValueError: If principal, rate, or time is negative
        ZeroDivisionError: If compounding_frequency is zero

    Example:
        >>> calculate_compound_interest(1000, 0.05, 2, 12)
        1104.94

    Note:
        The result is rounded to 2 decimal places for currency display.
    """
    if principal < 0 or rate < 0 or time < 0:
        raise ValueError("Principal, rate, and time must be non-negative")

    if compounding_frequency <= 0:
        raise ZeroDivisionError("Compounding frequency must be positive")

    amount = principal * (1 + rate / compounding_frequency) ** (compounding_frequency * time)
    return round(amount, 2)
```

### **Class Documentation**

```python
class DataProcessor:
    """
    A class for processing and analyzing data with various statistical methods.

    This class provides methods for data cleaning, transformation, and analysis.
    It supports both numerical and categorical data processing.

    Attributes:
        data: The dataset being processed
        cleaned_data: The cleaned version of the data
        statistics: Dictionary containing calculated statistics

    Example:
        >>> processor = DataProcessor([1, 2, 3, 4, 5])
        >>> processor.calculate_mean()
        3.0
        >>> processor.remove_outliers()
        >>> processor.get_statistics()
        {'mean': 3.0, 'std': 1.58, 'count': 5}
    """

    def __init__(self, data: List[Union[int, float]]) -> None:
        """
        Initialize the DataProcessor with a dataset.

        Args:
            data: List of numerical values to process

        Raises:
            TypeError: If data contains non-numerical values
            ValueError: If data is empty
        """
        if not data:
            raise ValueError("Data cannot be empty")

        if not all(isinstance(x, (int, float)) for x in data):
            raise TypeError("All data values must be numerical")

        self.data = data
        self.cleaned_data = data.copy()
        self.statistics = {}

    def calculate_mean(self) -> float:
        """
        Calculate the arithmetic mean of the data.

        Returns:
            The mean value of the dataset

        Example:
            >>> processor = DataProcessor([1, 2, 3, 4, 5])
            >>> processor.calculate_mean()
            3.0
        """
        return sum(self.cleaned_data) / len(self.cleaned_data)
```

## ğŸš« TESTING ANTI-PATTERNS

### **NEVER DO THESE IN TESTS:**

- âŒ Make real network calls
- âŒ Use real database connections
- âŒ Write tests that depend on external services
- âŒ Write tests that depend on file system state
- âŒ Use hardcoded test data without fixtures
- âŒ Write tests without proper assertions
- âŒ Skip error handling in tests
- âŒ Write tests that are too complex

### **COMMON TESTING MISTAKES:**

```python
# âŒ WRONG - Test with real network call
def test_fetch_data_wrong():
    response = requests.get('https://api.example.com/data')
    assert response.status_code == 200

# âœ… CORRECT - Mock the network call
@patch('requests.get')
def test_fetch_data_correct(mock_get):
    mock_get.return_value.status_code = 200
    mock_get.return_value.json.return_value = {'data': 'test'}

    result = fetch_data()
    assert result == {'data': 'test'}
    mock_get.assert_called_once_with('https://api.example.com/data')

# âŒ WRONG - Test without proper setup/teardown
def test_database_operation_wrong():
    # This test will fail if run multiple times
    user = create_user("test@example.com")
    assert user.email == "test@example.com"

# âœ… CORRECT - Use fixtures for setup/teardown
@pytest.fixture
def clean_database():
    # Setup
    yield
    # Teardown - clean up after test
    clear_all_tables()
```

## ğŸ“‹ TESTING CHECKLIST

### **Before Every Commit:**

- [ ] All new functions have unit tests
- [ ] All edge cases are tested
- [ ] All error conditions are tested
- [ ] All external dependencies are mocked
- [ ] Test coverage is >90%
- [ ] All tests pass
- [ ] No flaky tests
- [ ] Tests are fast (<1 second each)
- [ ] Tests are independent
- [ ] All public functions are documented

### **Test Quality Checklist:**

- [ ] Test names clearly describe what is being tested
- [ ] Tests follow AAA pattern (Arrange, Act, Assert)
- [ ] Tests are isolated and can run in any order
- [ ] Tests use appropriate fixtures
- [ ] Tests verify both success and failure scenarios
- [ ] Tests are maintainable and readable
- [ ] Tests don't have side effects
- [ ] Tests are deterministic (same result every time)
</file>

<file path="01_asyncio_basics.py">
"""
asyncio ê¸°ì´ˆ ì˜ˆì œ
ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì˜ ê¸°ë³¸ ê°œë…ì„ í•™ìŠµí•©ë‹ˆë‹¤.
"""

import asyncio
import time
from typing import List


async def simple_task(name: str, delay: float) -> str:
    """
    ê°„ë‹¨í•œ ë¹„ë™ê¸° ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

    Args:
        name: ì‘ì—… ì´ë¦„
        delay: ëŒ€ê¸° ì‹œê°„ (ì´ˆ)

    Returns:
        ì™„ë£Œ ë©”ì‹œì§€
    """
    print(f"ì‘ì—… {name} ì‹œì‘")
    await asyncio.sleep(delay)  # ë¹„ë™ê¸° ëŒ€ê¸°
    print(f"ì‘ì—… {name} ì™„ë£Œ")
    return f"{name} ì‘ì—…ì´ {delay}ì´ˆ í›„ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤"


async def fetch_data(url: str, delay: float) -> dict:
    """
    ê°€ìƒì˜ ë°ì´í„° í˜ì¹­ ì‘ì—…ì„ ì‹œë®¬ë ˆì´ì…˜í•©ë‹ˆë‹¤.

    Args:
        url: ê°€ìƒì˜ URL
        delay: ë„¤íŠ¸ì›Œí¬ ì§€ì—° ì‹œë®¬ë ˆì´ì…˜

    Returns:
        ê°€ìƒì˜ ë°ì´í„°
    """
    print(f"ë°ì´í„° ìš”ì²­: {url}")
    await asyncio.sleep(delay)
    return {
        "url": url,
        "data": f"URL {url}ì—ì„œ ê°€ì ¸ì˜¨ ë°ì´í„°",
        "timestamp": time.time(),
    }


def sync_task(name: str, delay: float) -> str:
    """
    ë™ê¸° ë²„ì „ì˜ ì‘ì—… í•¨ìˆ˜ (ë¹„êµìš©)

    Args:
        name: ì‘ì—… ì´ë¦„
        delay: ëŒ€ê¸° ì‹œê°„ (ì´ˆ)

    Returns:
        ì™„ë£Œ ë©”ì‹œì§€
    """
    print(f"ë™ê¸° ì‘ì—… {name} ì‹œì‘")
    time.sleep(delay)  # ë™ê¸° ëŒ€ê¸° (ë¸”ë¡œí‚¹)
    print(f"ë™ê¸° ì‘ì—… {name} ì™„ë£Œ")
    return f"{name} ì‘ì—…ì´ {delay}ì´ˆ í›„ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤"


async def demo_sleep_difference():
    """time.sleep vs asyncio.sleep ì°¨ì´ì  ë°ëª¨"""
    print("=== time.sleep vs asyncio.sleep ì°¨ì´ì  ===")

    async def async_task_with_sync_sleep(name: str, delay: float) -> str:
        """ë¹„ë™ê¸° í•¨ìˆ˜ì—ì„œ time.sleep ì‚¬ìš© (ì˜ëª»ëœ ë°©ë²•)"""
        print(f"ì‘ì—… {name} ì‹œì‘ (time.sleep ì‚¬ìš©)")
        time.sleep(delay)  # âŒ ì´ë ‡ê²Œ í•˜ë©´ ì•ˆë¨!
        print(f"ì‘ì—… {name} ì™„ë£Œ")
        return f"{name} ì™„ë£Œ"

    async def async_task_with_async_sleep(name: str, delay: float) -> str:
        """ë¹„ë™ê¸° í•¨ìˆ˜ì—ì„œ asyncio.sleep ì‚¬ìš© (ì˜¬ë°”ë¥¸ ë°©ë²•)"""
        print(f"ì‘ì—… {name} ì‹œì‘ (asyncio.sleep ì‚¬ìš©)")
        await asyncio.sleep(delay)  # âœ… ì˜¬ë°”ë¥¸ ë°©ë²•
        print(f"ì‘ì—… {name} ì™„ë£Œ")
        return f"{name} ì™„ë£Œ"

    # 1. time.sleepì„ ì‚¬ìš©í•œ ì˜ëª»ëœ ë¹„ë™ê¸° ì½”ë“œ
    print("\n--- time.sleep ì‚¬ìš© (ì˜ëª»ëœ ë°©ë²•) ---")
    start_time = time.time()
    results1 = await asyncio.gather(
        async_task_with_sync_sleep("A", 1.0),
        async_task_with_sync_sleep("B", 1.0),
        async_task_with_sync_sleep("C", 1.0),
    )
    end_time = time.time()
    print(f"time.sleep ì‚¬ìš© ì‹œê°„: {end_time - start_time:.2f}ì´ˆ")
    print("âŒ time.sleepì€ ë¸”ë¡œí‚¹ì´ë¯€ë¡œ ë™ì‹œ ì‹¤í–‰ì´ ì•ˆë¨!")

    # 2. asyncio.sleepì„ ì‚¬ìš©í•œ ì˜¬ë°”ë¥¸ ë¹„ë™ê¸° ì½”ë“œ
    print("\n--- asyncio.sleep ì‚¬ìš© (ì˜¬ë°”ë¥¸ ë°©ë²•) ---")
    start_time = time.time()
    results2 = await asyncio.gather(
        async_task_with_async_sleep("D", 1.0),
        async_task_with_async_sleep("E", 1.0),
        async_task_with_async_sleep("F", 1.0),
    )
    end_time = time.time()
    print(f"asyncio.sleep ì‚¬ìš© ì‹œê°„: {end_time - start_time:.2f}ì´ˆ")
    print("âœ… asyncio.sleepì€ ë…¼ë¸”ë¡œí‚¹ì´ë¯€ë¡œ ë™ì‹œ ì‹¤í–‰ë¨!")


async def main_basic():
    """ê¸°ë³¸ì ì¸ asyncio ì‚¬ìš©ë²•"""
    print("=== asyncio ê¸°ë³¸ ì˜ˆì œ ===")

    # 1. ë‹¨ì¼ ì½”ë£¨í‹´ ì‹¤í–‰
    result = await simple_task("A", 1.0)
    print(f"ê²°ê³¼: {result}")

    # 2. sleep ì°¨ì´ì  ë°ëª¨
    await demo_sleep_difference()

    # 3. ë™ê¸° í•¨ìˆ˜ë¡œ ìˆœì°¨ ì‹¤í–‰ (ëŠë¦¼)
    print("\n--- ë™ê¸° í•¨ìˆ˜ ìˆœì°¨ ì‹¤í–‰ ---")
    start_time = time.time()
    result1 = sync_task("B", 1.0)
    result2 = sync_task("C", 1.0)
    end_time = time.time()
    print(f"ë™ê¸° ìˆœì°¨ ì‹¤í–‰ ì‹œê°„: {end_time - start_time:.2f}ì´ˆ")

    # 4. ë¹„ë™ê¸° í•¨ìˆ˜ë¡œ ìˆœì°¨ ì‹¤í–‰ (ì—¬ì „íˆ ëŠë¦¼)
    print("\n--- ë¹„ë™ê¸° í•¨ìˆ˜ ìˆœì°¨ ì‹¤í–‰ ---")
    start_time = time.time()
    result1 = await simple_task("D", 1.0)
    result2 = await simple_task("E", 1.0)
    end_time = time.time()
    print(f"ë¹„ë™ê¸° ìˆœì°¨ ì‹¤í–‰ ì‹œê°„: {end_time - start_time:.2f}ì´ˆ")
    print("ğŸ’¡ ìˆœì°¨ ì‹¤í–‰ì€ ë™ê¸°/ë¹„ë™ê¸° ì°¨ì´ê°€ ì—†ìŠµë‹ˆë‹¤!")


async def main_concurrent():
    """ë™ì‹œ ì‹¤í–‰ ì˜ˆì œ"""
    print("\n=== ë™ì‹œ ì‹¤í–‰ ì˜ˆì œ ===")

    # 1. ë™ê¸° í•¨ìˆ˜ë¡œ ìˆœì°¨ ì‹¤í–‰ (ëŠë¦¼)
    print("--- ë™ê¸° í•¨ìˆ˜ ìˆœì°¨ ì‹¤í–‰ ---")
    start_time = time.time()
    result1 = sync_task("G", 1.0)
    result2 = sync_task("H", 1.0)
    result3 = sync_task("I", 1.0)
    end_time = time.time()
    sync_time = end_time - start_time
    print(f"ë™ê¸° ìˆœì°¨ ì‹¤í–‰ ì‹œê°„: {sync_time:.2f}ì´ˆ")

    # 2. ë¹„ë™ê¸° í•¨ìˆ˜ë¡œ ë™ì‹œ ì‹¤í–‰ (ë¹ ë¦„)
    print("\n--- ë¹„ë™ê¸° í•¨ìˆ˜ ë™ì‹œ ì‹¤í–‰ ---")
    start_time = time.time()
    results = await asyncio.gather(
        simple_task("J", 1.0), simple_task("K", 1.0), simple_task("L", 1.0)
    )
    end_time = time.time()
    async_time = end_time - start_time
    print(f"ë¹„ë™ê¸° ë™ì‹œ ì‹¤í–‰ ì‹œê°„: {async_time:.2f}ì´ˆ")
    print(f"ê²°ê³¼ë“¤: {results}")

    # 3. ì„±ëŠ¥ ë¹„êµ
    speedup = sync_time / async_time if async_time > 0 else 0
    print(f"\nğŸš€ ë¹„ë™ê¸° ë™ì‹œ ì‹¤í–‰ì´ {speedup:.1f}ë°° ë¹ ë¦…ë‹ˆë‹¤!")
    print(f"   ì‹œê°„ ì ˆì•½: {sync_time - async_time:.2f}ì´ˆ")


async def main_data_fetching():
    """ë°ì´í„° í˜ì¹­ ì‹œë®¬ë ˆì´ì…˜"""
    print("\n=== ë°ì´í„° í˜ì¹­ ì‹œë®¬ë ˆì´ì…˜ ===")

    urls = [
        "https://api.example.com/users",
        "https://api.example.com/posts",
        "https://api.example.com/comments",
    ]

    # ë™ì‹œì— ì—¬ëŸ¬ API í˜¸ì¶œ
    start_time = time.time()
    tasks = [fetch_data(url, 1.0) for url in urls]
    results = await asyncio.gather(*tasks)
    end_time = time.time()

    print(f"ëª¨ë“  ë°ì´í„° í˜ì¹­ ì™„ë£Œ: {end_time - start_time:.2f}ì´ˆ")
    for result in results:
        print(f"  - {result['url']}: {result['data']}")


async def main_with_tasks():
    """Task ê°ì²´ë¥¼ ì‚¬ìš©í•œ ì˜ˆì œ"""
    print("\n=== Task ê°ì²´ ì‚¬ìš© ì˜ˆì œ ===")

    # Task ìƒì„±
    task1 = asyncio.create_task(simple_task("Task1", 2.0))
    task2 = asyncio.create_task(simple_task("Task2", 1.0))
    task3 = asyncio.create_task(simple_task("Task3", 1.5))

    # ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
    results = await asyncio.gather(task1, task2, task3)
    print(f"Task ê²°ê³¼ë“¤: {results}")


async def main_with_timeout():
    """íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ ì˜ˆì œ"""
    print("\n=== íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ ì˜ˆì œ ===")

    try:
        # 2ì´ˆ íƒ€ì„ì•„ì›ƒìœ¼ë¡œ 3ì´ˆ ì‘ì—… ì‹¤í–‰
        result = await asyncio.wait_for(simple_task("Timeout", 3.0), timeout=2.0)
        print(f"ê²°ê³¼: {result}")
    except asyncio.TimeoutError:
        print("ì‘ì—…ì´ íƒ€ì„ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤!")


async def main_with_cancellation():
    """ì‘ì—… ì·¨ì†Œ ì˜ˆì œ"""
    print("\n=== ì‘ì—… ì·¨ì†Œ ì˜ˆì œ ===")

    async def long_running_task():
        try:
            for i in range(10):
                print(f"ê¸´ ì‘ì—… ì§„í–‰ ì¤‘... {i+1}/10")
                await asyncio.sleep(0.5)
            return "ê¸´ ì‘ì—… ì™„ë£Œ"
        except asyncio.CancelledError:
            print("ì‘ì—…ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤!")
            raise

    # 2ì´ˆ í›„ ì‘ì—… ì·¨ì†Œ
    task = asyncio.create_task(long_running_task())
    await asyncio.sleep(2.0)
    task.cancel()

    try:
        result = await task
        print(f"ê²°ê³¼: {result}")
    except asyncio.CancelledError:
        print("ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤")


if __name__ == "__main__":
    print("asyncio ê¸°ì´ˆ í•™ìŠµì„ ì‹œì‘í•©ë‹ˆë‹¤...\n")

    # ëª¨ë“  ì˜ˆì œ ì‹¤í–‰
    asyncio.run(main_basic())
    asyncio.run(main_concurrent())
    asyncio.run(main_data_fetching())
    asyncio.run(main_with_tasks())
    asyncio.run(main_with_timeout())
    asyncio.run(main_with_cancellation())

    print("\nasyncio ê¸°ì´ˆ í•™ìŠµì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
</file>

<file path="02_websocket_basics.py">
"""
ì›¹ì†Œì¼“ ê¸°ì´ˆ ì˜ˆì œ
ì›¹ì†Œì¼“ ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ì˜ ê¸°ë³¸ ì‚¬ìš©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.
"""

import asyncio
import json
import logging
from typing import Dict, Set, Optional
from datetime import datetime

import websockets
from websockets.server import WebSocketServerProtocol
from websockets.exceptions import ConnectionClosed

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class WebSocketServer:
    """ì›¹ì†Œì¼“ ì„œë²„ í´ë˜ìŠ¤"""

    def __init__(self, host: str = "localhost", port: int = 8765):
        self.host = host
        self.port = port
        self.clients: Set[WebSocketServerProtocol] = set()
        self.message_count = 0

    async def register_client(self, websocket: WebSocketServerProtocol) -> None:
        """ìƒˆ í´ë¼ì´ì–¸íŠ¸ ë“±ë¡"""
        self.clients.add(websocket)
        logger.info(f"ìƒˆ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°: {websocket.remote_address}")
        logger.info(f"í˜„ì¬ ì—°ê²°ëœ í´ë¼ì´ì–¸íŠ¸ ìˆ˜: {len(self.clients)}")

    async def unregister_client(self, websocket: WebSocketServerProtocol) -> None:
        """í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í•´ì œ"""
        self.clients.discard(websocket)
        logger.info(f"í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í•´ì œ: {websocket.remote_address}")
        logger.info(f"í˜„ì¬ ì—°ê²°ëœ í´ë¼ì´ì–¸íŠ¸ ìˆ˜: {len(self.clients)}")

    async def broadcast_message(
        self, message: str, sender: Optional[WebSocketServerProtocol] = None
    ) -> None:
        """ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸"""
        if not self.clients:
            return

        # ì—°ê²°ì´ ëŠì–´ì§„ í´ë¼ì´ì–¸íŠ¸ ì œê±°
        disconnected_clients = set()

        for client in self.clients.copy():
            try:
                await client.send(message)
            except ConnectionClosed:
                disconnected_clients.add(client)

        # ëŠì–´ì§„ ì—°ê²° ì œê±°
        for client in disconnected_clients:
            await self.unregister_client(client)

    async def handle_client(self, websocket: WebSocketServerProtocol) -> None:
        """í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì²˜ë¦¬"""
        await self.register_client(websocket)

        try:
            async for message in websocket:
                await self.process_message(websocket, message)
        except ConnectionClosed:
            logger.info("í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì´ ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
        except Exception as e:
            logger.error(f"í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        finally:
            await self.unregister_client(websocket)

    async def process_message(
        self, websocket: WebSocketServerProtocol, message: str
    ) -> None:
        """ë©”ì‹œì§€ ì²˜ë¦¬"""
        self.message_count += 1

        try:
            # JSON ë©”ì‹œì§€ íŒŒì‹± ì‹œë„
            data = json.loads(message)
            message_type = data.get("type", "unknown")

            if message_type == "echo":
                # ì—ì½” ë©”ì‹œì§€
                response = {
                    "type": "echo_response",
                    "original_message": data.get("message", ""),
                    "timestamp": datetime.now().isoformat(),
                    "server_message_count": self.message_count,
                }
                await websocket.send(json.dumps(response))

            elif message_type == "broadcast":
                # ë¸Œë¡œë“œìºìŠ¤íŠ¸ ë©”ì‹œì§€
                broadcast_data = {
                    "type": "broadcast",
                    "message": data.get("message", ""),
                    "sender": str(websocket.remote_address),
                    "timestamp": datetime.now().isoformat(),
                }
                await self.broadcast_message(json.dumps(broadcast_data), websocket)

            elif message_type == "ping":
                # í•‘ ë©”ì‹œì§€
                pong_response = {
                    "type": "pong",
                    "timestamp": datetime.now().isoformat(),
                }
                await websocket.send(json.dumps(pong_response))

            else:
                # ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…
                error_response = {
                    "type": "error",
                    "message": f"ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…: {message_type}",
                    "timestamp": datetime.now().isoformat(),
                }
                await websocket.send(json.dumps(error_response))

        except json.JSONDecodeError:
            # JSONì´ ì•„ë‹Œ ì¼ë°˜ í…ìŠ¤íŠ¸ ë©”ì‹œì§€
            response = (
                f"ì„œë²„ê°€ ë°›ì€ ë©”ì‹œì§€: {message} (ë©”ì‹œì§€ ë²ˆí˜¸: {self.message_count})"
            )
            await websocket.send(response)

    async def start_server(self) -> None:
        """ì„œë²„ ì‹œì‘"""
        logger.info(f"ì›¹ì†Œì¼“ ì„œë²„ ì‹œì‘: ws://{self.host}:{self.port}")

        async def handler(websocket):
            await self.handle_client(websocket)

        async with websockets.serve(
            handler,
            self.host,
            self.port,
            ping_interval=20,  # 20ì´ˆë§ˆë‹¤ í•‘ ì „ì†¡
            ping_timeout=10,  # 10ì´ˆ ë‚´ í•‘ ì‘ë‹µ ì—†ìœ¼ë©´ ì—°ê²° ì¢…ë£Œ
            close_timeout=10,  # ì—°ê²° ì¢…ë£Œ íƒ€ì„ì•„ì›ƒ
        ):
            logger.info("ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. Ctrl+Cë¡œ ì¢…ë£Œí•˜ì„¸ìš”.")
            await asyncio.Future()  # ì„œë²„ë¥¼ ê³„ì† ì‹¤í–‰


class WebSocketClient:
    """ì›¹ì†Œì¼“ í´ë¼ì´ì–¸íŠ¸ í´ë˜ìŠ¤"""

    def __init__(self, uri: str):
        self.uri = uri
        self.websocket: Optional[websockets.WebSocketServerProtocol] = None

    async def connect(self) -> None:
        """ì„œë²„ì— ì—°ê²°"""
        try:
            self.websocket = await websockets.connect(self.uri)
            logger.info(f"ì„œë²„ì— ì—°ê²°ë¨: {self.uri}")
        except Exception as e:
            logger.error(f"ì„œë²„ ì—°ê²° ì‹¤íŒ¨: {e}")
            raise

    async def disconnect(self) -> None:
        """ì„œë²„ ì—°ê²° í•´ì œ"""
        if self.websocket:
            await self.websocket.close()
            logger.info("ì„œë²„ ì—°ê²° í•´ì œ")

    async def send_message(self, message: str) -> None:
        """ë©”ì‹œì§€ ì „ì†¡"""
        if not self.websocket:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        await self.websocket.send(message)
        logger.info(f"ë©”ì‹œì§€ ì „ì†¡: {message}")

    async def send_json(self, data: dict) -> None:
        """JSON ë©”ì‹œì§€ ì „ì†¡"""
        message = json.dumps(data)
        await self.send_message(message)

    async def receive_message(self) -> str:
        """ë©”ì‹œì§€ ìˆ˜ì‹ """
        if not self.websocket:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        message = await self.websocket.recv()
        logger.info(f"ë©”ì‹œì§€ ìˆ˜ì‹ : {message}")
        return message

    async def listen_for_messages(self) -> None:
        """ë©”ì‹œì§€ ìˆ˜ì‹  ëŒ€ê¸°"""
        if not self.websocket:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        try:
            async for message in self.websocket:
                logger.info(f"ìˆ˜ì‹ ëœ ë©”ì‹œì§€: {message}")
        except ConnectionClosed:
            logger.info("ì„œë²„ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
        except Exception as e:
            logger.error(f"ë©”ì‹œì§€ ìˆ˜ì‹  ì¤‘ ì˜¤ë¥˜: {e}")


async def demo_client_interactions():
    """í´ë¼ì´ì–¸íŠ¸ ìƒí˜¸ì‘ìš© ë°ëª¨"""
    client = WebSocketClient("ws://localhost:8765")

    try:
        await client.connect()

        # 1. ì¼ë°˜ í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ì „ì†¡
        await client.send_message("ì•ˆë…•í•˜ì„¸ìš”, ì„œë²„!")

        # 2. JSON ë©”ì‹œì§€ ì „ì†¡ (ì—ì½”)
        echo_data = {"type": "echo", "message": "ì´ ë©”ì‹œì§€ë¥¼ ì—ì½”í•´ì£¼ì„¸ìš”"}
        await client.send_json(echo_data)

        # 3. í•‘ ë©”ì‹œì§€ ì „ì†¡
        ping_data = {"type": "ping"}
        await client.send_json(ping_data)

        # 4. ë¸Œë¡œë“œìºìŠ¤íŠ¸ ë©”ì‹œì§€ ì „ì†¡
        broadcast_data = {
            "type": "broadcast",
            "message": "ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡ë˜ëŠ” ë©”ì‹œì§€ì…ë‹ˆë‹¤",
        }
        await client.send_json(broadcast_data)

        # ì‘ë‹µ ìˆ˜ì‹ 
        for _ in range(4):
            try:
                response = await asyncio.wait_for(client.receive_message(), timeout=2.0)
                print(f"ì„œë²„ ì‘ë‹µ: {response}")
            except asyncio.TimeoutError:
                print("ì‘ë‹µ íƒ€ì„ì•„ì›ƒ")
                break

    except Exception as e:
        logger.error(f"í´ë¼ì´ì–¸íŠ¸ ë°ëª¨ ì˜¤ë¥˜: {e}")
    finally:
        await client.disconnect()


async def demo_multiple_clients():
    """ì—¬ëŸ¬ í´ë¼ì´ì–¸íŠ¸ ë°ëª¨"""
    clients = []

    try:
        # 3ê°œì˜ í´ë¼ì´ì–¸íŠ¸ ìƒì„±
        for i in range(3):
            client = WebSocketClient(f"ws://localhost:8765")
            await client.connect()
            clients.append(client)

            # ê° í´ë¼ì´ì–¸íŠ¸ê°€ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ë©”ì‹œì§€ ì „ì†¡
            broadcast_data = {
                "type": "broadcast",
                "message": f"í´ë¼ì´ì–¸íŠ¸ {i+1}ì—ì„œ ì „ì†¡í•œ ë©”ì‹œì§€",
            }
            await client.send_json(broadcast_data)

            # ì ì‹œ ëŒ€ê¸°
            await asyncio.sleep(0.5)

        # ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì˜ ì‘ë‹µ ìˆ˜ì‹ 
        for client in clients:
            try:
                response = await asyncio.wait_for(client.receive_message(), timeout=1.0)
                print(f"í´ë¼ì´ì–¸íŠ¸ ì‘ë‹µ: {response}")
            except asyncio.TimeoutError:
                print("ì‘ë‹µ íƒ€ì„ì•„ì›ƒ")

    finally:
        # ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í•´ì œ
        for client in clients:
            await client.disconnect()


async def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    print("ì›¹ì†Œì¼“ ê¸°ì´ˆ í•™ìŠµì„ ì‹œì‘í•©ë‹ˆë‹¤...\n")

    # ì„œë²„ ì‹œì‘ (ë°±ê·¸ë¼ìš´ë“œ)
    server = WebSocketServer()
    server_task = asyncio.create_task(server.start_server())

    # ì„œë²„ ì‹œì‘ ëŒ€ê¸°
    await asyncio.sleep(1)

    print("=== ë‹¨ì¼ í´ë¼ì´ì–¸íŠ¸ ë°ëª¨ ===")
    await demo_client_interactions()

    print("\n=== ì—¬ëŸ¬ í´ë¼ì´ì–¸íŠ¸ ë°ëª¨ ===")
    await demo_multiple_clients()

    # ì„œë²„ ì¢…ë£Œ
    server_task.cancel()
    try:
        await server_task
    except asyncio.CancelledError:
        pass

    print("\nì›¹ì†Œì¼“ ê¸°ì´ˆ í•™ìŠµì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="03_realtime_chat.py">
"""
ì‹¤ì‹œê°„ ì±„íŒ… ì• í”Œë¦¬ì¼€ì´ì…˜
asyncioì™€ ì›¹ì†Œì¼“ì„ ê²°í•©í•œ ì‹¤ì „ ì˜ˆì œ
"""

import asyncio
import json
import logging
import uuid
from datetime import datetime
from typing import Dict, Set, Optional, List
from dataclasses import dataclass, asdict
from enum import Enum

try:
    import websockets
    from websockets.server import WebSocketServerProtocol
    from websockets.exceptions import ConnectionClosed
except ImportError:
    print("websockets ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    print("ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì„¤ì¹˜í•˜ì„¸ìš”: pip install websockets")
    exit(1)

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MessageType(Enum):
    """ë©”ì‹œì§€ íƒ€ì… ì—´ê±°í˜•"""

    JOIN = "join"
    LEAVE = "leave"
    MESSAGE = "message"
    USER_LIST = "user_list"
    ERROR = "error"
    HEARTBEAT = "heartbeat"


@dataclass
class User:
    """ì‚¬ìš©ì ì •ë³´"""

    id: str
    username: str
    websocket: WebSocketServerProtocol
    joined_at: datetime
    last_activity: datetime

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "username": self.username,
            "joined_at": self.joined_at.isoformat(),
            "last_activity": self.last_activity.isoformat(),
        }


@dataclass
class ChatMessage:
    """ì±„íŒ… ë©”ì‹œì§€"""

    id: str
    user_id: str
    username: str
    message: str
    timestamp: datetime
    message_type: MessageType = MessageType.MESSAGE

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "user_id": self.user_id,
            "username": self.username,
            "message": self.message,
            "timestamp": self.timestamp.isoformat(),
            "type": self.message_type.value,
        }


class ChatRoom:
    """ì±„íŒ…ë°© ê´€ë¦¬ í´ë˜ìŠ¤"""

    def __init__(self, room_id: str = "general"):
        self.room_id = room_id
        self.users: Dict[str, User] = {}
        self.message_history: List[ChatMessage] = []
        self.max_history = 100  # ìµœëŒ€ ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ìˆ˜

    async def add_user(self, websocket: WebSocketServerProtocol, username: str) -> User:
        """ì‚¬ìš©ì ì¶”ê°€"""
        user_id = str(uuid.uuid4())
        now = datetime.now()

        user = User(
            id=user_id,
            username=username,
            websocket=websocket,
            joined_at=now,
            last_activity=now,
        )

        self.users[user_id] = user

        # ì…ì¥ ë©”ì‹œì§€ ìƒì„±
        join_message = ChatMessage(
            id=str(uuid.uuid4()),
            user_id="system",
            username="System",
            message=f"{username}ë‹˜ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤.",
            timestamp=now,
            message_type=MessageType.JOIN,
        )

        await self.broadcast_message(join_message)
        await self.send_user_list()

        logger.info(f"ì‚¬ìš©ì ì¶”ê°€: {username} (ID: {user_id})")
        return user

    async def remove_user(self, user_id: str) -> None:
        """ì‚¬ìš©ì ì œê±°"""
        if user_id in self.users:
            user = self.users[user_id]
            del self.users[user_id]

            # í‡´ì¥ ë©”ì‹œì§€ ìƒì„±
            leave_message = ChatMessage(
                id=str(uuid.uuid4()),
                user_id="system",
                username="System",
                message=f"{user.username}ë‹˜ì´ í‡´ì¥í–ˆìŠµë‹ˆë‹¤.",
                timestamp=datetime.now(),
                message_type=MessageType.LEAVE,
            )

            await self.broadcast_message(leave_message)
            await self.send_user_list()

            logger.info(f"ì‚¬ìš©ì ì œê±°: {user.username} (ID: {user_id})")

    async def send_message(self, user_id: str, message: str) -> None:
        """ë©”ì‹œì§€ ì „ì†¡"""
        if user_id not in self.users:
            return

        user = self.users[user_id]
        user.last_activity = datetime.now()

        # ì±„íŒ… ë©”ì‹œì§€ ìƒì„±
        chat_message = ChatMessage(
            id=str(uuid.uuid4()),
            user_id=user_id,
            username=user.username,
            message=message,
            timestamp=datetime.now(),
        )

        # ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
        self.message_history.append(chat_message)
        if len(self.message_history) > self.max_history:
            self.message_history.pop(0)

        # ëª¨ë“  ì‚¬ìš©ìì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        await self.broadcast_message(chat_message)

    async def broadcast_message(self, message: ChatMessage) -> None:
        """ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸"""
        if not self.users:
            return

        message_data = json.dumps(message.to_dict())
        disconnected_users = []

        for user in self.users.values():
            try:
                await user.websocket.send(message_data)
            except ConnectionClosed:
                disconnected_users.append(user.id)
            except Exception as e:
                logger.error(f"ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨ (ì‚¬ìš©ì: {user.username}): {e}")
                disconnected_users.append(user.id)

        # ì—°ê²°ì´ ëŠì–´ì§„ ì‚¬ìš©ìë“¤ ì œê±°
        for user_id in disconnected_users:
            await self.remove_user(user_id)

    async def send_user_list(self) -> None:
        """ì‚¬ìš©ì ëª©ë¡ ì „ì†¡"""
        user_list_data = {
            "type": MessageType.USER_LIST.value,
            "users": [user.to_dict() for user in self.users.values()],
            "timestamp": datetime.now().isoformat(),
        }

        message_data = json.dumps(user_list_data)
        disconnected_users = []

        for user in self.users.values():
            try:
                await user.websocket.send(message_data)
            except ConnectionClosed:
                disconnected_users.append(user.id)
            except Exception as e:
                logger.error(f"ì‚¬ìš©ì ëª©ë¡ ì „ì†¡ ì‹¤íŒ¨ (ì‚¬ìš©ì: {user.username}): {e}")
                disconnected_users.append(user.id)

        # ì—°ê²°ì´ ëŠì–´ì§„ ì‚¬ìš©ìë“¤ ì œê±°
        for user_id in disconnected_users:
            await self.remove_user(user_id)

    async def send_message_history(self, user_id: str, limit: int = 20) -> None:
        """ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ì „ì†¡"""
        if user_id not in self.users:
            return

        user = self.users[user_id]
        recent_messages = self.message_history[-limit:] if self.message_history else []

        history_data = {
            "type": "message_history",
            "messages": [msg.to_dict() for msg in recent_messages],
            "timestamp": datetime.now().isoformat(),
        }

        try:
            await user.websocket.send(json.dumps(history_data))
        except Exception as e:
            logger.error(f"ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ì „ì†¡ ì‹¤íŒ¨: {e}")

    def get_room_stats(self) -> dict:
        """ì±„íŒ…ë°© í†µê³„"""
        return {
            "room_id": self.room_id,
            "user_count": len(self.users),
            "message_count": len(self.message_history),
            "users": [user.to_dict() for user in self.users.values()],
        }


class ChatServer:
    """ì±„íŒ… ì„œë²„ í´ë˜ìŠ¤"""

    def __init__(self, host: str = "localhost", port: int = 8765):
        self.host = host
        self.port = port
        self.chat_room = ChatRoom()
        self.heartbeat_interval = 30  # 30ì´ˆë§ˆë‹¤ í•˜íŠ¸ë¹„íŠ¸

    async def handle_client(
        self, websocket: WebSocketServerProtocol, path: str
    ) -> None:
        """í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì²˜ë¦¬"""
        user = None

        try:
            # ì‚¬ìš©ìëª… ìš”ì²­
            await websocket.send(
                json.dumps(
                    {"type": "request_username", "message": "ì‚¬ìš©ìëª…ì„ ì…ë ¥í•˜ì„¸ìš”:"}
                )
            )

            # ì‚¬ìš©ìëª… ìˆ˜ì‹ 
            username_response = await websocket.recv()
            username_data = json.loads(username_response)
            username = username_data.get("username", f"User_{uuid.uuid4().hex[:8]}")

            # ì‚¬ìš©ì ì¶”ê°€
            user = await self.chat_room.add_user(websocket, username)

            # ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ì „ì†¡
            await self.chat_room.send_message_history(user.id, 20)

            # ë©”ì‹œì§€ ìˆ˜ì‹  ë£¨í”„
            async for message in websocket:
                await self.process_message(user, message)

        except ConnectionClosed:
            logger.info("í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì´ ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
        except Exception as e:
            logger.error(f"í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        finally:
            if user:
                await self.chat_room.remove_user(user.id)

    async def process_message(self, user: User, message: str) -> None:
        """ë©”ì‹œì§€ ì²˜ë¦¬"""
        try:
            data = json.loads(message)
            message_type = data.get("type", "message")

            if message_type == "chat_message":
                # ì±„íŒ… ë©”ì‹œì§€
                chat_text = data.get("message", "").strip()
                if chat_text:
                    await self.chat_room.send_message(user.id, chat_text)

            elif message_type == "heartbeat":
                # í•˜íŠ¸ë¹„íŠ¸ ì‘ë‹µ
                user.last_activity = datetime.now()
                await user.websocket.send(
                    json.dumps(
                        {
                            "type": "heartbeat_response",
                            "timestamp": datetime.now().isoformat(),
                        }
                    )
                )

            elif message_type == "get_users":
                # ì‚¬ìš©ì ëª©ë¡ ìš”ì²­
                await self.chat_room.send_user_list()

            elif message_type == "get_history":
                # ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ìš”ì²­
                limit = data.get("limit", 20)
                await self.chat_room.send_message_history(user.id, limit)

            else:
                # ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…
                await user.websocket.send(
                    json.dumps(
                        {
                            "type": "error",
                            "message": f"ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…: {message_type}",
                            "timestamp": datetime.now().isoformat(),
                        }
                    )
                )

        except json.JSONDecodeError:
            # JSONì´ ì•„ë‹Œ ì¼ë°˜ í…ìŠ¤íŠ¸ ë©”ì‹œì§€
            if message.strip():
                await self.chat_room.send_message(user.id, message)
        except Exception as e:
            logger.error(f"ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")

    async def heartbeat_monitor(self) -> None:
        """í•˜íŠ¸ë¹„íŠ¸ ëª¨ë‹ˆí„°ë§"""
        while True:
            await asyncio.sleep(self.heartbeat_interval)

            current_time = datetime.now()
            inactive_users = []

            # ë¹„í™œì„± ì‚¬ìš©ì í™•ì¸
            for user in self.chat_room.users.values():
                time_diff = (current_time - user.last_activity).total_seconds()
                if time_diff > self.heartbeat_interval * 2:  # 2ë°° ì‹œê°„ ë™ì•ˆ ë¹„í™œì„±
                    inactive_users.append(user.id)

            # ë¹„í™œì„± ì‚¬ìš©ì ì œê±°
            for user_id in inactive_users:
                await self.chat_room.remove_user(user_id)
                logger.info(f"ë¹„í™œì„± ì‚¬ìš©ì ì œê±°: {user_id}")

    async def start_server(self) -> None:
        """ì„œë²„ ì‹œì‘"""
        logger.info(f"ì±„íŒ… ì„œë²„ ì‹œì‘: ws://{self.host}:{self.port}")

        # í•˜íŠ¸ë¹„íŠ¸ ëª¨ë‹ˆí„°ë§ ì‹œì‘
        heartbeat_task = asyncio.create_task(self.heartbeat_monitor())

        try:
            async with websockets.serve(
                self.handle_client,
                self.host,
                self.port,
                ping_interval=20,
                ping_timeout=10,
                close_timeout=10,
            ):
                logger.info("ì±„íŒ… ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. Ctrl+Cë¡œ ì¢…ë£Œí•˜ì„¸ìš”.")
                await asyncio.Future()  # ì„œë²„ë¥¼ ê³„ì† ì‹¤í–‰
        finally:
            heartbeat_task.cancel()


class ChatClient:
    """ì±„íŒ… í´ë¼ì´ì–¸íŠ¸ í´ë˜ìŠ¤"""

    def __init__(self, uri: str, username: str):
        self.uri = uri
        self.username = username
        self.websocket: Optional[websockets.WebSocketServerProtocol] = None
        self.running = False

    async def connect(self) -> None:
        """ì„œë²„ì— ì—°ê²°"""
        try:
            self.websocket = await websockets.connect(self.uri)
            self.running = True
            logger.info(f"ì±„íŒ… ì„œë²„ì— ì—°ê²°ë¨: {self.uri}")

            # ì‚¬ìš©ìëª… ì „ì†¡
            await self.websocket.send(json.dumps({"username": self.username}))

        except Exception as e:
            logger.error(f"ì„œë²„ ì—°ê²° ì‹¤íŒ¨: {e}")
            raise

    async def disconnect(self) -> None:
        """ì„œë²„ ì—°ê²° í•´ì œ"""
        self.running = False
        if self.websocket:
            await self.websocket.close()
            logger.info("ì„œë²„ ì—°ê²° í•´ì œ")

    async def send_message(self, message: str) -> None:
        """ë©”ì‹œì§€ ì „ì†¡"""
        if not self.websocket or not self.running:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        message_data = {"type": "chat_message", "message": message}
        await self.websocket.send(json.dumps(message_data))

    async def listen_for_messages(self) -> None:
        """ë©”ì‹œì§€ ìˆ˜ì‹  ëŒ€ê¸°"""
        if not self.websocket:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        try:
            async for message in self.websocket:
                if not self.running:
                    break

                try:
                    data = json.loads(message)
                    message_type = data.get("type", "unknown")

                    if message_type == "request_username":
                        # ì‚¬ìš©ìëª… ìš”ì²­ (ì´ë¯¸ ì—°ê²° ì‹œ ì „ì†¡ë¨)
                        continue
                    elif message_type == "message_history":
                        # ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬
                        messages = data.get("messages", [])
                        print(f"\n=== ìµœê·¼ ë©”ì‹œì§€ ({len(messages)}ê°œ) ===")
                        for msg in messages:
                            timestamp = datetime.fromisoformat(msg["timestamp"])
                            print(
                                f"[{timestamp.strftime('%H:%M:%S')}] {msg['username']}: {msg['message']}"
                            )
                        print("=== í˜„ì¬ ì±„íŒ… ===\n")
                    elif message_type == "user_list":
                        # ì‚¬ìš©ì ëª©ë¡
                        users = data.get("users", [])
                        print(
                            f"\ní˜„ì¬ ì ‘ì†ì ({len(users)}ëª…): {', '.join([u['username'] for u in users])}\n"
                        )
                    elif message_type in ["join", "leave"]:
                        # ì…ì¥/í‡´ì¥ ë©”ì‹œì§€
                        print(f"ğŸ“¢ {data.get('message', '')}")
                    elif message_type == "error":
                        # ì˜¤ë¥˜ ë©”ì‹œì§€
                        print(f"âŒ ì˜¤ë¥˜: {data.get('message', '')}")
                    else:
                        # ì¼ë°˜ ì±„íŒ… ë©”ì‹œì§€
                        timestamp = datetime.fromisoformat(data["timestamp"])
                        print(
                            f"[{timestamp.strftime('%H:%M:%S')}] {data['username']}: {data['message']}"
                        )

                except json.JSONDecodeError:
                    # JSONì´ ì•„ë‹Œ ì¼ë°˜ í…ìŠ¤íŠ¸
                    print(f"ì„œë²„ ë©”ì‹œì§€: {message}")

        except ConnectionClosed:
            logger.info("ì„œë²„ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
        except Exception as e:
            logger.error(f"ë©”ì‹œì§€ ìˆ˜ì‹  ì¤‘ ì˜¤ë¥˜: {e}")

    async def start_interactive_mode(self) -> None:
        """ëŒ€í™”í˜• ëª¨ë“œ ì‹œì‘"""
        print(f"ì±„íŒ… í´ë¼ì´ì–¸íŠ¸ ì‹œì‘ (ì‚¬ìš©ì: {self.username})")
        print("ëª…ë ¹ì–´: /users (ì‚¬ìš©ì ëª©ë¡), /history (ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬), /quit (ì¢…ë£Œ)")
        print("-" * 50)

        # ë©”ì‹œì§€ ìˆ˜ì‹  íƒœìŠ¤í¬ ì‹œì‘
        receive_task = asyncio.create_task(self.listen_for_messages())

        try:
            while self.running:
                # ì‚¬ìš©ì ì…ë ¥ ë°›ê¸°
                try:
                    user_input = await asyncio.wait_for(
                        asyncio.get_event_loop().run_in_executor(None, input),
                        timeout=1.0,
                    )

                    if user_input.strip():
                        if user_input.strip() == "/quit":
                            break
                        elif user_input.strip() == "/users":
                            await self.websocket.send(json.dumps({"type": "get_users"}))
                        elif user_input.strip() == "/history":
                            await self.websocket.send(
                                json.dumps({"type": "get_history", "limit": 10})
                            )
                        else:
                            await self.send_message(user_input)

                except asyncio.TimeoutError:
                    # íƒ€ì„ì•„ì›ƒì€ ì •ìƒ (ì…ë ¥ ëŒ€ê¸° ì¤‘)
                    continue
                except KeyboardInterrupt:
                    break

        finally:
            self.running = False
            receive_task.cancel()
            try:
                await receive_task
            except asyncio.CancelledError:
                pass


async def demo_chat_server():
    """ì±„íŒ… ì„œë²„ ë°ëª¨"""
    server = ChatServer()
    await server.start_server()


async def demo_chat_client():
    """ì±„íŒ… í´ë¼ì´ì–¸íŠ¸ ë°ëª¨"""
    import random

    username = f"User_{random.randint(1000, 9999)}"
    client = ChatClient("ws://localhost:8765", username)

    try:
        await client.connect()
        await client.start_interactive_mode()
    finally:
        await client.disconnect()


async def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    print("ì‹¤ì‹œê°„ ì±„íŒ… ì• í”Œë¦¬ì¼€ì´ì…˜ ë°ëª¨")
    print("1. ì„œë²„ ì‹¤í–‰")
    print("2. í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰")
    print("3. ì¢…ë£Œ")

    choice = input("ì„ íƒí•˜ì„¸ìš” (1-3): ").strip()

    if choice == "1":
        print("ì±„íŒ… ì„œë²„ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
        await demo_chat_server()
    elif choice == "2":
        print("ì±„íŒ… í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
        await demo_chat_client()
    else:
        print("í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="04_advanced_websocket.py">
"""
ê³ ê¸‰ ì›¹ì†Œì¼“ ì• í”Œë¦¬ì¼€ì´ì…˜
ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°, ëª¨ë‹ˆí„°ë§, ë¶€í•˜ ë¶„ì‚° ë“± ê³ ê¸‰ ê¸°ëŠ¥ êµ¬í˜„
"""

import asyncio
import json
import logging
import random
import time
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set, Any, Callable
from dataclasses import dataclass, asdict
from enum import Enum
from collections import defaultdict, deque
import statistics

try:
    import websockets
    from websockets.server import WebSocketServerProtocol
    from websockets.exceptions import ConnectionClosed
except ImportError:
    print("websockets ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    print("ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì„¤ì¹˜í•˜ì„¸ìš”: pip install websockets")
    exit(1)

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class StreamType(Enum):
    """ìŠ¤íŠ¸ë¦¼ íƒ€ì…"""

    SENSOR_DATA = "sensor_data"
    SYSTEM_METRICS = "system_metrics"
    USER_ACTIVITY = "user_activity"
    MARKET_DATA = "market_data"
    LOG_EVENTS = "log_events"


@dataclass
class StreamData:
    """ìŠ¤íŠ¸ë¦¼ ë°ì´í„°"""

    id: str
    stream_type: StreamType
    data: Dict[str, Any]
    timestamp: datetime
    source: str

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "stream_type": self.stream_type.value,
            "data": self.data,
            "timestamp": self.timestamp.isoformat(),
            "source": self.source,
        }


@dataclass
class ClientSubscription:
    """í´ë¼ì´ì–¸íŠ¸ êµ¬ë… ì •ë³´"""

    client_id: str
    stream_types: Set[StreamType]
    filters: Dict[str, Any]
    last_activity: datetime


class StreamProcessor:
    """ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ì²˜ë¦¬ê¸°"""

    def __init__(self):
        self.processors: Dict[StreamType, List[Callable]] = defaultdict(list)
        self.aggregators: Dict[StreamType, deque] = defaultdict(
            lambda: deque(maxlen=1000)
        )

    def register_processor(self, stream_type: StreamType, processor: Callable) -> None:
        """ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ê¸° ë“±ë¡"""
        self.processors[stream_type].append(processor)

    async def process_data(self, data: StreamData) -> StreamData:
        """ë°ì´í„° ì²˜ë¦¬"""
        # ë°ì´í„° ì§‘ê³„
        self.aggregators[data.stream_type].append(data)

        # ë“±ë¡ëœ ì²˜ë¦¬ê¸°ë“¤ ì‹¤í–‰
        for processor in self.processors[data.stream_type]:
            try:
                data = await processor(data)
            except Exception as e:
                logger.error(f"ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")

        return data

    def get_aggregated_data(
        self, stream_type: StreamType, window_size: int = 100
    ) -> Dict[str, Any]:
        """ì§‘ê³„ëœ ë°ì´í„° ë°˜í™˜"""
        data_points = list(self.aggregators[stream_type])[-window_size:]

        if not data_points:
            return {}

        # ê¸°ë³¸ í†µê³„ ê³„ì‚°
        if stream_type == StreamType.SENSOR_DATA:
            values = [point.data.get("value", 0) for point in data_points]
            return {
                "count": len(values),
                "mean": statistics.mean(values),
                "min": min(values),
                "max": max(values),
                "std": statistics.stdev(values) if len(values) > 1 else 0,
                "latest": values[-1] if values else None,
            }
        elif stream_type == StreamType.SYSTEM_METRICS:
            cpu_values = [point.data.get("cpu_usage", 0) for point in data_points]
            memory_values = [point.data.get("memory_usage", 0) for point in data_points]
            return {
                "cpu": {
                    "mean": statistics.mean(cpu_values),
                    "max": max(cpu_values),
                    "current": cpu_values[-1] if cpu_values else None,
                },
                "memory": {
                    "mean": statistics.mean(memory_values),
                    "max": max(memory_values),
                    "current": memory_values[-1] if memory_values else None,
                },
            }

        return {"count": len(data_points)}


class LoadBalancer:
    """ë¡œë“œ ë°¸ëŸ°ì„œ"""

    def __init__(self):
        self.servers: Dict[str, Dict[str, Any]] = {}
        self.server_weights: Dict[str, float] = {}
        self.current_connections: Dict[str, int] = defaultdict(int)

    def add_server(self, server_id: str, capacity: int, weight: float = 1.0) -> None:
        """ì„œë²„ ì¶”ê°€"""
        self.servers[server_id] = {
            "capacity": capacity,
            "weight": weight,
            "status": "active",
        }
        self.server_weights[server_id] = weight

    def get_best_server(self) -> Optional[str]:
        """ìµœì  ì„œë²„ ì„ íƒ"""
        available_servers = [
            server_id
            for server_id, server in self.servers.items()
            if server["status"] == "active"
            and self.current_connections[server_id] < server["capacity"]
        ]

        if not available_servers:
            return None

        # ê°€ì¤‘ì¹˜ ê¸°ë°˜ ì„ íƒ
        total_weight = sum(
            self.server_weights[server_id] for server_id in available_servers
        )
        if total_weight == 0:
            return available_servers[0]

        choice = random.uniform(0, total_weight)
        current_weight = 0

        for server_id in available_servers:
            current_weight += self.server_weights[server_id]
            if choice <= current_weight:
                return server_id

        return available_servers[-1]

    def update_connections(self, server_id: str, delta: int) -> None:
        """ì—°ê²° ìˆ˜ ì—…ë°ì´íŠ¸"""
        self.current_connections[server_id] += delta
        self.current_connections[server_id] = max(
            0, self.current_connections[server_id]
        )


class AdvancedWebSocketServer:
    """ê³ ê¸‰ ì›¹ì†Œì¼“ ì„œë²„"""

    def __init__(self, host: str = "localhost", port: int = 8765):
        self.host = host
        self.port = port
        self.clients: Dict[str, WebSocketServerProtocol] = {}
        self.subscriptions: Dict[str, ClientSubscription] = {}
        self.stream_processor = StreamProcessor()
        self.load_balancer = LoadBalancer()
        self.metrics = {
            "total_connections": 0,
            "active_connections": 0,
            "messages_sent": 0,
            "messages_received": 0,
            "start_time": datetime.now(),
        }

        # ìŠ¤íŠ¸ë¦¼ ìƒì„±ê¸° ë“±ë¡
        self._register_stream_generators()
        self._register_data_processors()

    def _register_stream_generators(self) -> None:
        """ìŠ¤íŠ¸ë¦¼ ìƒì„±ê¸° ë“±ë¡"""
        asyncio.create_task(self._generate_sensor_data())
        asyncio.create_task(self._generate_system_metrics())
        asyncio.create_task(self._generate_user_activity())
        asyncio.create_task(self._generate_market_data())

    def _register_data_processors(self) -> None:
        """ë°ì´í„° ì²˜ë¦¬ê¸° ë“±ë¡"""

        # ì„¼ì„œ ë°ì´í„° ì´ìƒì¹˜ íƒì§€
        async def detect_anomalies(data: StreamData) -> StreamData:
            if data.stream_type == StreamType.SENSOR_DATA:
                value = data.data.get("value", 0)
                aggregated = self.stream_processor.get_aggregated_data(
                    StreamType.SENSOR_DATA
                )

                if aggregated and "mean" in aggregated and "std" in aggregated:
                    mean = aggregated["mean"]
                    std = aggregated["std"]

                    if std > 0 and abs(value - mean) > 3 * std:  # 3ì‹œê·¸ë§ˆ ê·œì¹™
                        data.data["anomaly"] = True
                        data.data["anomaly_score"] = abs(value - mean) / std
                        logger.warning(
                            f"ì´ìƒì¹˜ íƒì§€: {value} (í‰ê· : {mean:.2f}, í‘œì¤€í¸ì°¨: {std:.2f})"
                        )

            return data

        # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ì„ê³„ê°’ ì²´í¬
        async def check_thresholds(data: StreamData) -> StreamData:
            if data.stream_type == StreamType.SYSTEM_METRICS:
                cpu = data.data.get("cpu_usage", 0)
                memory = data.data.get("memory_usage", 0)

                if cpu > 80:
                    data.data["cpu_alert"] = True
                    logger.warning(f"ë†’ì€ CPU ì‚¬ìš©ë¥ : {cpu}%")

                if memory > 90:
                    data.data["memory_alert"] = True
                    logger.warning(f"ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {memory}%")

            return data

        self.stream_processor.register_processor(
            StreamType.SENSOR_DATA, detect_anomalies
        )
        self.stream_processor.register_processor(
            StreamType.SYSTEM_METRICS, check_thresholds
        )

    async def _generate_sensor_data(self) -> None:
        """ì„¼ì„œ ë°ì´í„° ìƒì„±"""
        while True:
            await asyncio.sleep(1)  # 1ì´ˆë§ˆë‹¤

            data = StreamData(
                id=str(uuid.uuid4()),
                stream_type=StreamType.SENSOR_DATA,
                data={
                    "value": random.uniform(20, 30),  # ì˜¨ë„ ì„¼ì„œ
                    "unit": "celsius",
                    "location": random.choice(["room1", "room2", "room3"]),
                },
                timestamp=datetime.now(),
                source="temperature_sensor",
            )

            await self._broadcast_stream_data(data)

    async def _generate_system_metrics(self) -> None:
        """ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìƒì„±"""
        while True:
            await asyncio.sleep(2)  # 2ì´ˆë§ˆë‹¤

            data = StreamData(
                id=str(uuid.uuid4()),
                stream_type=StreamType.SYSTEM_METRICS,
                data={
                    "cpu_usage": random.uniform(10, 100),
                    "memory_usage": random.uniform(30, 95),
                    "disk_usage": random.uniform(20, 80),
                    "network_io": random.uniform(0, 1000),
                },
                timestamp=datetime.now(),
                source="system_monitor",
            )

            await self._broadcast_stream_data(data)

    async def _generate_user_activity(self) -> None:
        """ì‚¬ìš©ì í™œë™ ë°ì´í„° ìƒì„±"""
        while True:
            await asyncio.sleep(5)  # 5ì´ˆë§ˆë‹¤

            data = StreamData(
                id=str(uuid.uuid4()),
                stream_type=StreamType.USER_ACTIVITY,
                data={
                    "user_id": f"user_{random.randint(1, 100)}",
                    "action": random.choice(
                        ["login", "logout", "page_view", "click", "purchase"]
                    ),
                    "page": random.choice(["/home", "/products", "/cart", "/checkout"]),
                    "session_duration": random.uniform(0, 3600),
                },
                timestamp=datetime.now(),
                source="user_tracker",
            )

            await self._broadcast_stream_data(data)

    async def _generate_market_data(self) -> None:
        """ì‹œì¥ ë°ì´í„° ìƒì„±"""
        while True:
            await asyncio.sleep(0.5)  # 0.5ì´ˆë§ˆë‹¤

            data = StreamData(
                id=str(uuid.uuid4()),
                stream_type=StreamType.MARKET_DATA,
                data={
                    "symbol": random.choice(["AAPL", "GOOGL", "MSFT", "TSLA"]),
                    "price": random.uniform(100, 500),
                    "volume": random.randint(1000, 10000),
                    "change": random.uniform(-5, 5),
                },
                timestamp=datetime.now(),
                source="market_feed",
            )

            await self._broadcast_stream_data(data)

    async def _broadcast_stream_data(self, data: StreamData) -> None:
        """ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë¸Œë¡œë“œìºìŠ¤íŠ¸"""
        # ë°ì´í„° ì²˜ë¦¬
        processed_data = await self.stream_processor.process_data(data)

        # êµ¬ë…ìë“¤ì—ê²Œ ì „ì†¡
        for client_id, subscription in self.subscriptions.items():
            if data.stream_type in subscription.stream_types:
                if client_id in self.clients:
                    try:
                        message = json.dumps(processed_data.to_dict())
                        await self.clients[client_id].send(message)
                        self.metrics["messages_sent"] += 1
                    except ConnectionClosed:
                        await self._remove_client(client_id)
                    except Exception as e:
                        logger.error(f"ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨ (í´ë¼ì´ì–¸íŠ¸: {client_id}): {e}")

    async def handle_client(
        self, websocket: WebSocketServerProtocol, path: str
    ) -> None:
        """í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì²˜ë¦¬"""
        client_id = str(uuid.uuid4())
        self.clients[client_id] = websocket
        self.metrics["total_connections"] += 1
        self.metrics["active_connections"] += 1

        logger.info(
            f"ìƒˆ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°: {client_id} (ì´ ì—°ê²°: {self.metrics['active_connections']})"
        )

        try:
            async for message in websocket:
                await self._process_client_message(client_id, message)
        except ConnectionClosed:
            logger.info(f"í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ: {client_id}")
        except Exception as e:
            logger.error(f"í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ (í´ë¼ì´ì–¸íŠ¸: {client_id}): {e}")
        finally:
            await self._remove_client(client_id)

    async def _process_client_message(self, client_id: str, message: str) -> None:
        """í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ ì²˜ë¦¬"""
        self.metrics["messages_received"] += 1

        try:
            data = json.loads(message)
            message_type = data.get("type", "unknown")

            if message_type == "subscribe":
                # ìŠ¤íŠ¸ë¦¼ êµ¬ë…
                stream_types = [StreamType(t) for t in data.get("stream_types", [])]
                filters = data.get("filters", {})

                self.subscriptions[client_id] = ClientSubscription(
                    client_id=client_id,
                    stream_types=set(stream_types),
                    filters=filters,
                    last_activity=datetime.now(),
                )

                await self._send_response(
                    client_id,
                    {
                        "type": "subscription_confirmed",
                        "stream_types": [t.value for t in stream_types],
                        "timestamp": datetime.now().isoformat(),
                    },
                )

            elif message_type == "unsubscribe":
                # êµ¬ë… í•´ì œ
                if client_id in self.subscriptions:
                    del self.subscriptions[client_id]

                await self._send_response(
                    client_id,
                    {
                        "type": "unsubscription_confirmed",
                        "timestamp": datetime.now().isoformat(),
                    },
                )

            elif message_type == "get_metrics":
                # ì„œë²„ ë©”íŠ¸ë¦­ ìš”ì²­
                await self._send_response(
                    client_id,
                    {
                        "type": "server_metrics",
                        "metrics": self.metrics,
                        "uptime": (
                            datetime.now() - self.metrics["start_time"]
                        ).total_seconds(),
                        "timestamp": datetime.now().isoformat(),
                    },
                )

            elif message_type == "get_aggregated_data":
                # ì§‘ê³„ëœ ë°ì´í„° ìš”ì²­
                stream_type = StreamType(data.get("stream_type", "sensor_data"))
                window_size = data.get("window_size", 100)

                aggregated = self.stream_processor.get_aggregated_data(
                    stream_type, window_size
                )

                await self._send_response(
                    client_id,
                    {
                        "type": "aggregated_data",
                        "stream_type": stream_type.value,
                        "data": aggregated,
                        "timestamp": datetime.now().isoformat(),
                    },
                )

            elif message_type == "ping":
                # í•‘ ì‘ë‹µ
                await self._send_response(
                    client_id, {"type": "pong", "timestamp": datetime.now().isoformat()}
                )

            else:
                # ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…
                await self._send_response(
                    client_id,
                    {
                        "type": "error",
                        "message": f"ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…: {message_type}",
                        "timestamp": datetime.now().isoformat(),
                    },
                )

        except json.JSONDecodeError:
            await self._send_response(
                client_id,
                {
                    "type": "error",
                    "message": "ìœ íš¨í•˜ì§€ ì•Šì€ JSON ë©”ì‹œì§€",
                    "timestamp": datetime.now().isoformat(),
                },
            )
        except Exception as e:
            logger.error(f"ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
            await self._send_response(
                client_id,
                {
                    "type": "error",
                    "message": f"ì„œë²„ ì˜¤ë¥˜: {str(e)}",
                    "timestamp": datetime.now().isoformat(),
                },
            )

    async def _send_response(self, client_id: str, response: dict) -> None:
        """í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì‘ë‹µ ì „ì†¡"""
        if client_id in self.clients:
            try:
                await self.clients[client_id].send(json.dumps(response))
                self.metrics["messages_sent"] += 1
            except ConnectionClosed:
                await self._remove_client(client_id)
            except Exception as e:
                logger.error(f"ì‘ë‹µ ì „ì†¡ ì‹¤íŒ¨ (í´ë¼ì´ì–¸íŠ¸: {client_id}): {e}")

    async def _remove_client(self, client_id: str) -> None:
        """í´ë¼ì´ì–¸íŠ¸ ì œê±°"""
        if client_id in self.clients:
            del self.clients[client_id]
            self.metrics["active_connections"] -= 1

        if client_id in self.subscriptions:
            del self.subscriptions[client_id]

        logger.info(
            f"í´ë¼ì´ì–¸íŠ¸ ì œê±°: {client_id} (í™œì„± ì—°ê²°: {self.metrics['active_connections']})"
        )

    async def start_server(self) -> None:
        """ì„œë²„ ì‹œì‘"""
        logger.info(f"ê³ ê¸‰ ì›¹ì†Œì¼“ ì„œë²„ ì‹œì‘: ws://{self.host}:{self.port}")

        async with websockets.serve(
            self.handle_client,
            self.host,
            self.port,
            ping_interval=30,
            ping_timeout=10,
            close_timeout=10,
        ):
            logger.info("ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. Ctrl+Cë¡œ ì¢…ë£Œí•˜ì„¸ìš”.")
            await asyncio.Future()


class AdvancedWebSocketClient:
    """ê³ ê¸‰ ì›¹ì†Œì¼“ í´ë¼ì´ì–¸íŠ¸"""

    def __init__(self, uri: str, client_name: str = "AdvancedClient"):
        self.uri = uri
        self.client_name = client_name
        self.websocket: Optional[websockets.WebSocketServerProtocol] = None
        self.running = False
        self.subscriptions: Set[StreamType] = set()

    async def connect(self) -> None:
        """ì„œë²„ì— ì—°ê²°"""
        try:
            self.websocket = await websockets.connect(self.uri)
            self.running = True
            logger.info(f"ì„œë²„ì— ì—°ê²°ë¨: {self.uri}")
        except Exception as e:
            logger.error(f"ì„œë²„ ì—°ê²° ì‹¤íŒ¨: {e}")
            raise

    async def disconnect(self) -> None:
        """ì„œë²„ ì—°ê²° í•´ì œ"""
        self.running = False
        if self.websocket:
            await self.websocket.close()
            logger.info("ì„œë²„ ì—°ê²° í•´ì œ")

    async def subscribe(
        self, stream_types: List[StreamType], filters: Dict[str, Any] = None
    ) -> None:
        """ìŠ¤íŠ¸ë¦¼ êµ¬ë…"""
        if not self.websocket:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        message = {
            "type": "subscribe",
            "stream_types": [t.value for t in stream_types],
            "filters": filters or {},
        }

        await self.websocket.send(json.dumps(message))
        self.subscriptions.update(stream_types)
        logger.info(f"êµ¬ë… ìš”ì²­: {[t.value for t in stream_types]}")

    async def unsubscribe(self) -> None:
        """êµ¬ë… í•´ì œ"""
        if not self.websocket:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        message = {"type": "unsubscribe"}
        await self.websocket.send(json.dumps(message))
        self.subscriptions.clear()
        logger.info("êµ¬ë… í•´ì œ")

    async def get_server_metrics(self) -> None:
        """ì„œë²„ ë©”íŠ¸ë¦­ ìš”ì²­"""
        if not self.websocket:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        message = {"type": "get_metrics"}
        await self.websocket.send(json.dumps(message))

    async def get_aggregated_data(
        self, stream_type: StreamType, window_size: int = 100
    ) -> None:
        """ì§‘ê³„ëœ ë°ì´í„° ìš”ì²­"""
        if not self.websocket:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        message = {
            "type": "get_aggregated_data",
            "stream_type": stream_type.value,
            "window_size": window_size,
        }
        await self.websocket.send(json.dumps(message))

    async def listen_for_messages(self) -> None:
        """ë©”ì‹œì§€ ìˆ˜ì‹  ëŒ€ê¸°"""
        if not self.websocket:
            raise RuntimeError("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        try:
            async for message in self.websocket:
                if not self.running:
                    break

                try:
                    data = json.loads(message)
                    await self._handle_message(data)
                except json.JSONDecodeError:
                    logger.info(f"ìˆ˜ì‹ ëœ ë©”ì‹œì§€: {message}")

        except ConnectionClosed:
            logger.info("ì„œë²„ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
        except Exception as e:
            logger.error(f"ë©”ì‹œì§€ ìˆ˜ì‹  ì¤‘ ì˜¤ë¥˜: {e}")

    async def _handle_message(self, data: dict) -> None:
        """ë©”ì‹œì§€ ì²˜ë¦¬"""
        message_type = data.get("type", "unknown")

        if message_type == "subscription_confirmed":
            logger.info(f"êµ¬ë… í™•ì¸: {data.get('stream_types', [])}")

        elif message_type == "server_metrics":
            metrics = data.get("metrics", {})
            uptime = data.get("uptime", 0)
            print(f"\n=== ì„œë²„ ë©”íŠ¸ë¦­ ===")
            print(f"í™œì„± ì—°ê²°: {metrics.get('active_connections', 0)}")
            print(f"ì´ ì—°ê²°: {metrics.get('total_connections', 0)}")
            print(f"ì „ì†¡ëœ ë©”ì‹œì§€: {metrics.get('messages_sent', 0)}")
            print(f"ìˆ˜ì‹ ëœ ë©”ì‹œì§€: {metrics.get('messages_received', 0)}")
            print(f"ì—…íƒ€ì„: {uptime:.2f}ì´ˆ")
            print("=" * 20)

        elif message_type == "aggregated_data":
            stream_type = data.get("stream_type", "unknown")
            aggregated_data = data.get("data", {})
            print(f"\n=== {stream_type} ì§‘ê³„ ë°ì´í„° ===")
            for key, value in aggregated_data.items():
                if isinstance(value, dict):
                    print(f"{key}:")
                    for sub_key, sub_value in value.items():
                        print(f"  {sub_key}: {sub_value}")
                else:
                    print(f"{key}: {value}")
            print("=" * 30)

        elif message_type in [
            "sensor_data",
            "system_metrics",
            "user_activity",
            "market_data",
        ]:
            # ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ì¶œë ¥
            timestamp = datetime.fromisoformat(data["timestamp"])
            source = data.get("source", "unknown")

            print(f"[{timestamp.strftime('%H:%M:%S')}] {message_type} from {source}")

            # íŠ¹ë³„í•œ ë°ì´í„° í‘œì‹œ
            if "anomaly" in data.get("data", {}):
                print("ğŸš¨ ì´ìƒì¹˜ íƒì§€!")
            if "cpu_alert" in data.get("data", {}):
                print("âš ï¸ CPU ê²½ê³ !")
            if "memory_alert" in data.get("data", {}):
                print("âš ï¸ ë©”ëª¨ë¦¬ ê²½ê³ !")

        else:
            logger.info(f"ìˆ˜ì‹ ëœ ë©”ì‹œì§€: {data}")


async def demo_advanced_server():
    """ê³ ê¸‰ ì„œë²„ ë°ëª¨"""
    server = AdvancedWebSocketServer()
    await server.start_server()


async def demo_advanced_client():
    """ê³ ê¸‰ í´ë¼ì´ì–¸íŠ¸ ë°ëª¨"""
    client = AdvancedWebSocketClient("ws://localhost:8765", "DemoClient")

    try:
        await client.connect()

        # ì„¼ì„œ ë°ì´í„°ì™€ ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ êµ¬ë…
        await client.subscribe([StreamType.SENSOR_DATA, StreamType.SYSTEM_METRICS])

        # ì„œë²„ ë©”íŠ¸ë¦­ ìš”ì²­
        await client.get_server_metrics()

        # ë©”ì‹œì§€ ìˆ˜ì‹  ì‹œì‘
        await client.listen_for_messages()

    except KeyboardInterrupt:
        logger.info("í´ë¼ì´ì–¸íŠ¸ ì¢…ë£Œ")
    finally:
        await client.disconnect()


async def demo_data_analysis():
    """ë°ì´í„° ë¶„ì„ ë°ëª¨"""
    client = AdvancedWebSocketClient("ws://localhost:8765", "AnalysisClient")

    try:
        await client.connect()

        # ëª¨ë“  ìŠ¤íŠ¸ë¦¼ êµ¬ë…
        await client.subscribe(
            [
                StreamType.SENSOR_DATA,
                StreamType.SYSTEM_METRICS,
                StreamType.USER_ACTIVITY,
                StreamType.MARKET_DATA,
            ]
        )

        # ì£¼ê¸°ì ìœ¼ë¡œ ì§‘ê³„ ë°ì´í„° ìš”ì²­
        async def periodic_analysis():
            while True:
                await asyncio.sleep(10)  # 10ì´ˆë§ˆë‹¤
                print("\n=== ë°ì´í„° ë¶„ì„ ===")
                await client.get_aggregated_data(StreamType.SENSOR_DATA, 50)
                await client.get_aggregated_data(StreamType.SYSTEM_METRICS, 50)
                await client.get_server_metrics()

        # ë¶„ì„ íƒœìŠ¤í¬ì™€ ë©”ì‹œì§€ ìˆ˜ì‹ ì„ ë™ì‹œì— ì‹¤í–‰
        analysis_task = asyncio.create_task(periodic_analysis())

        try:
            await client.listen_for_messages()
        finally:
            analysis_task.cancel()
            try:
                await analysis_task
            except asyncio.CancelledError:
                pass

    except KeyboardInterrupt:
        logger.info("ë¶„ì„ í´ë¼ì´ì–¸íŠ¸ ì¢…ë£Œ")
    finally:
        await client.disconnect()


async def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    print("ê³ ê¸‰ ì›¹ì†Œì¼“ ì• í”Œë¦¬ì¼€ì´ì…˜ ë°ëª¨")
    print("1. ì„œë²„ ì‹¤í–‰")
    print("2. ê¸°ë³¸ í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰")
    print("3. ë°ì´í„° ë¶„ì„ í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰")
    print("4. ì¢…ë£Œ")

    choice = input("ì„ íƒí•˜ì„¸ìš” (1-4): ").strip()

    if choice == "1":
        print("ê³ ê¸‰ ì›¹ì†Œì¼“ ì„œë²„ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
        await demo_advanced_server()
    elif choice == "2":
        print("ê¸°ë³¸ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
        await demo_advanced_client()
    elif choice == "3":
        print("ë°ì´í„° ë¶„ì„ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
        await demo_data_analysis()
    else:
        print("í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="package.json">
{}
</file>

<file path="quick_websocket_test.py">
#!/usr/bin/env python3
"""
ë¹ ë¥¸ ì›¹ì†Œì¼“ í…ŒìŠ¤íŠ¸ - ì›ë³¸ ì½”ë“œ ì‚¬ìš©
"""
import asyncio
from websockets_test import test_websocket


async def main():
    # ì„œë²„ ì‹œì‘
    from websocket_basics import WebSocketServer

    server = WebSocketServer()
    server_task = asyncio.create_task(server.start_server())

    # ì ì‹œ ëŒ€ê¸° í›„ í…ŒìŠ¤íŠ¸
    await asyncio.sleep(1)

    # ê°„ë‹¨í•œ í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤íŠ¸
    import websockets
    import json

    try:
        async with websockets.connect("ws://localhost:8765") as websocket:
            print("âœ… ì—°ê²° ì„±ê³µ")

            # í…ìŠ¤íŠ¸ ë©”ì‹œì§€
            await websocket.send("Hello Server!")
            response = await websocket.recv()
            print(f"ì‘ë‹µ: {response}")

            # JSON ë©”ì‹œì§€
            await websocket.send(json.dumps({"type": "ping"}))
            response = await websocket.recv()
            print(f"í•‘ ì‘ë‹µ: {response}")

            print("âœ… ì›¹ì†Œì¼“ ê¸°ë³¸ ê¸°ëŠ¥ ì •ìƒ ì‘ë™!")

    except Exception as e:
        print(f"âŒ ì˜¤ë¥˜: {e}")

    # ì„œë²„ ì¢…ë£Œ
    server_task.cancel()
    try:
        await server_task
    except asyncio.CancelledError:
        pass


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="README.md">
# asyncioì™€ ì›¹ì†Œì¼“ ê¸°ì´ˆë¶€í„° ê³ ê¸‰ê¹Œì§€

ì´ í”„ë¡œì íŠ¸ëŠ” Pythonì˜ asyncioì™€ ì›¹ì†Œì¼“ì„ ì‚¬ìš©í•œ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì„ ë‹¨ê³„ì ìœ¼ë¡œ í•™ìŠµí•  ìˆ˜ ìˆë„ë¡ êµ¬ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.

## ğŸ“š í•™ìŠµ ìˆœì„œ

### 1. asyncio ê¸°ì´ˆ (`01_asyncio_basics.py`)

- ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì˜ ê¸°ë³¸ ê°œë…
- ì½”ë£¨í‹´, ì´ë²¤íŠ¸ ë£¨í”„, Task ê°ì²´
- ë™ì‹œ ì‹¤í–‰ê³¼ ìˆœì°¨ ì‹¤í–‰ì˜ ì°¨ì´
- íƒ€ì„ì•„ì›ƒê³¼ ì‘ì—… ì·¨ì†Œ

### 2. ì›¹ì†Œì¼“ ê¸°ì´ˆ (`02_websocket_basics.py`)

- ì›¹ì†Œì¼“ ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
- ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸
- ì—°ê²° ê´€ë¦¬ì™€ ì˜¤ë¥˜ ì²˜ë¦¬
- JSON ë©”ì‹œì§€ ì²˜ë¦¬

### 3. ì‹¤ì‹œê°„ ì±„íŒ… ì• í”Œë¦¬ì¼€ì´ì…˜ (`03_realtime_chat.py`)

- asyncioì™€ ì›¹ì†Œì¼“ì„ ê²°í•©í•œ ì‹¤ì „ ì˜ˆì œ
- ì‚¬ìš©ì ê´€ë¦¬ì™€ ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬
- í•˜íŠ¸ë¹„íŠ¸ ëª¨ë‹ˆí„°ë§
- ëŒ€í™”í˜• í´ë¼ì´ì–¸íŠ¸

### 4. ê³ ê¸‰ ì›¹ì†Œì¼“ ì• í”Œë¦¬ì¼€ì´ì…˜ (`04_advanced_websocket.py`)

- ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°
- ë°ì´í„° ì²˜ë¦¬ì™€ ì§‘ê³„
- ì´ìƒì¹˜ íƒì§€ì™€ ì„ê³„ê°’ ëª¨ë‹ˆí„°ë§
- ì„œë²„ ë©”íŠ¸ë¦­ê³¼ ë¶€í•˜ ê´€ë¦¬

## ğŸš€ ì„¤ì¹˜ ë° ì‹¤í–‰

### 1. ì˜ì¡´ì„± ì„¤ì¹˜

```bash
pip install -r requirements.txt
```

### 2. ì˜ˆì œ ì‹¤í–‰

#### asyncio ê¸°ì´ˆ í•™ìŠµ

```bash
python 01_asyncio_basics.py
```

#### ì›¹ì†Œì¼“ ê¸°ì´ˆ í•™ìŠµ

```bash
python 02_websocket_basics.py
```

#### ì‹¤ì‹œê°„ ì±„íŒ… (ì„œë²„)

```bash
python 03_realtime_chat.py
# ì„ íƒ: 1 (ì„œë²„ ì‹¤í–‰)
```

#### ì‹¤ì‹œê°„ ì±„íŒ… (í´ë¼ì´ì–¸íŠ¸)

```bash
python 03_realtime_chat.py
# ì„ íƒ: 2 (í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰)
```

#### ê³ ê¸‰ ì›¹ì†Œì¼“ (ì„œë²„)

```bash
python 04_advanced_websocket.py
# ì„ íƒ: 1 (ì„œë²„ ì‹¤í–‰)
```

#### ê³ ê¸‰ ì›¹ì†Œì¼“ (í´ë¼ì´ì–¸íŠ¸)

```bash
python 04_advanced_websocket.py
# ì„ íƒ: 2 (ê¸°ë³¸ í´ë¼ì´ì–¸íŠ¸) ë˜ëŠ” 3 (ë¶„ì„ í´ë¼ì´ì–¸íŠ¸)
```

## ğŸ“– ì£¼ìš” ê°œë…

### asyncio í•µì‹¬ ê°œë…

- **Coroutine**: `async def`ë¡œ ì •ì˜ëœ ë¹„ë™ê¸° í•¨ìˆ˜
- **Event Loop**: ë¹„ë™ê¸° ì‘ì—…ë“¤ì„ ê´€ë¦¬í•˜ëŠ” ë£¨í”„
- **await**: ë‹¤ë¥¸ ì½”ë£¨í‹´ì˜ ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦¼
- **Task**: ì‹¤í–‰ ì¤‘ì¸ ì½”ë£¨í‹´ì„ ê´€ë¦¬í•˜ëŠ” ê°ì²´

### ì›¹ì†Œì¼“ í•µì‹¬ ê°œë…

- **Handshake**: í´ë¼ì´ì–¸íŠ¸ì™€ ì„œë²„ ê°„ ì—°ê²° ì„¤ì •
- **Frame**: ë°ì´í„° ì „ì†¡ì˜ ê¸°ë³¸ ë‹¨ìœ„
- **Ping/Pong**: ì—°ê²° ìƒíƒœ í™•ì¸ ë©”ì»¤ë‹ˆì¦˜
- **Close**: ì—°ê²° ì¢…ë£Œ í”„ë¡œì„¸ìŠ¤

### ì‹¤ë¬´ í™œìš© íŒ¨í„´

- **Connection Pooling**: ì—°ê²° ì¬ì‚¬ìš©ìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™”
- **Message Queuing**: ë©”ì‹œì§€ ìˆœì„œ ë³´ì¥ê³¼ ë°°ì¹˜ ì²˜ë¦¬
- **Load Balancing**: ì—¬ëŸ¬ ì„œë²„ ê°„ ë¶€í•˜ ë¶„ì‚°
- **Monitoring**: ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê³¼ ì•Œë¦¼

## ğŸ”§ ê³ ê¸‰ ê¸°ëŠ¥

### 1. ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°

- ì„¼ì„œ ë°ì´í„°, ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­, ì‚¬ìš©ì í™œë™ ë“± ë‹¤ì–‘í•œ ë°ì´í„° ì†ŒìŠ¤
- ì‹¤ì‹œê°„ ì²˜ë¦¬ì™€ ì§‘ê³„
- ì´ìƒì¹˜ íƒì§€ì™€ ì„ê³„ê°’ ëª¨ë‹ˆí„°ë§

### 2. ì—°ê²° ê´€ë¦¬

- ìë™ ì¬ì—°ê²°
- í•˜íŠ¸ë¹„íŠ¸ ëª¨ë‹ˆí„°ë§
- ì—°ê²° í’€ ê´€ë¦¬

### 3. ì„±ëŠ¥ ìµœì í™”

- ë¹„ë™ê¸° I/O í™œìš©
- ë©”ì‹œì§€ ë°°ì¹˜ ì²˜ë¦¬
- ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë°ì´í„° êµ¬ì¡°

### 4. ì˜¤ë¥˜ ì²˜ë¦¬

- ì—°ê²° ëŠê¹€ ê°ì§€
- ìë™ ì¬ì‹œë„
- ìš°ì•„í•œ ì„œë¹„ìŠ¤ ì¤‘ë‹¨

## ğŸ¯ ì‹¤ë¬´ ì ìš© ì‚¬ë¡€

### 1. ì‹¤ì‹œê°„ ì±„íŒ… ì‹œìŠ¤í…œ

- ë‹¤ì¤‘ ì‚¬ìš©ì ì§€ì›
- ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬
- ì‚¬ìš©ì ìƒíƒœ ê´€ë¦¬

### 2. IoT ë°ì´í„° ìˆ˜ì§‘

- ì„¼ì„œ ë°ì´í„° ì‹¤ì‹œê°„ ìˆ˜ì§‘
- ë°ì´í„° ì „ì²˜ë¦¬ì™€ í•„í„°ë§
- ì´ìƒ ìƒí™© ì•Œë¦¼

### 3. ê¸ˆìœµ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°

- ì‹¤ì‹œê°„ ì‹œì¥ ë°ì´í„°
- ê³ ë¹ˆë„ ê±°ë˜ ì²˜ë¦¬
- ìœ„í—˜ ê´€ë¦¬

### 4. ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§

- ì„œë²„ ì„±ëŠ¥ ë©”íŠ¸ë¦­
- ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë°
- ì•Œë¦¼ ì‹œìŠ¤í…œ

## ğŸ“ í•™ìŠµ íŒ

1. **ë‹¨ê³„ë³„ í•™ìŠµ**: ê° íŒŒì¼ì„ ìˆœì„œëŒ€ë¡œ ì‹¤í–‰í•´ë³´ì„¸ìš”
2. **ì½”ë“œ ìˆ˜ì •**: ì˜ˆì œ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ë©° ì‹¤í—˜í•´ë³´ì„¸ìš”
3. **ë””ë²„ê¹…**: ë¡œê·¸ë¥¼ í†µí•´ ë¹„ë™ê¸° ì‘ì—…ì˜ íë¦„ì„ íŒŒì•…í•˜ì„¸ìš”
4. **ì„±ëŠ¥ ì¸¡ì •**: ì‹œê°„ ì¸¡ì •ì„ í†µí•´ ë™ê¸°/ë¹„ë™ê¸°ì˜ ì°¨ì´ë¥¼ í™•ì¸í•˜ì„¸ìš”

## ğŸ› ë¬¸ì œ í•´ê²°

### ì¼ë°˜ì ì¸ ë¬¸ì œë“¤

1. **ImportError: No module named 'websockets'**

   ```bash
   pip install websockets
   ```

2. **ì—°ê²° ê±°ë¶€ ì˜¤ë¥˜**

   - ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
   - í¬íŠ¸ ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥¸ì§€ í™•ì¸

3. **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€**
   - ì—°ê²°ì´ ì œëŒ€ë¡œ í•´ì œë˜ëŠ”ì§€ í™•ì¸
   - ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ í¬ê¸° ì œí•œ

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

- [Python asyncio ê³µì‹ ë¬¸ì„œ](https://docs.python.org/3/library/asyncio.html)
- [WebSocket RFC 6455](https://tools.ietf.org/html/rfc6455)
- [websockets ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ](https://websockets.readthedocs.io/)

## ğŸ¤ ê¸°ì—¬í•˜ê¸°

ì´ í”„ë¡œì íŠ¸ì— ê¸°ì—¬í•˜ê³  ì‹¶ìœ¼ì‹œë‹¤ë©´:

1. ì´ìŠˆë¥¼ ìƒì„±í•˜ì—¬ ê°œì„  ì‚¬í•­ì„ ì œì•ˆí•˜ì„¸ìš”
2. í’€ ë¦¬í€˜ìŠ¤íŠ¸ë¥¼ í†µí•´ ì½”ë“œ ê°œì„ ì„ ì œì•ˆí•˜ì„¸ìš”
3. ìƒˆë¡œìš´ ì˜ˆì œë‚˜ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì¶”ê°€í•˜ì„¸ìš”

---

**Happy Coding! ğŸš€**
</file>

<file path="requirements.txt">
websockets>=11.0.0
asyncio
</file>

<file path="simple_websocket_test.py">
#!/usr/bin/env python3
"""
ê°„ë‹¨í•œ ì›¹ì†Œì¼“ ì„œë²„ í…ŒìŠ¤íŠ¸
"""
import asyncio
import websockets
import json
from datetime import datetime


class SimpleWebSocketServer:
    def __init__(self):
        self.clients = set()

    async def handle_client(self, websocket):
        """í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì²˜ë¦¬"""
        self.clients.add(websocket)
        print(f"í´ë¼ì´ì–¸íŠ¸ ì—°ê²°: {websocket.remote_address}")

        try:
            async for message in websocket:
                print(f"ë°›ì€ ë©”ì‹œì§€: {message}")

                try:
                    data = json.loads(message)
                    if data.get("type") == "ping":
                        response = {
                            "type": "pong",
                            "timestamp": datetime.now().isoformat(),
                        }
                        await websocket.send(json.dumps(response))
                    else:
                        await websocket.send(f"ì—ì½”: {message}")
                except json.JSONDecodeError:
                    await websocket.send(f"ì—ì½”: {message}")

        except websockets.exceptions.ConnectionClosed:
            print("í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ")
        finally:
            self.clients.discard(websocket)

    async def start_server(self):
        """ì„œë²„ ì‹œì‘"""
        print("ì›¹ì†Œì¼“ ì„œë²„ ì‹œì‘: ws://localhost:8765")

        async with websockets.serve(self.handle_client, "localhost", 8765):
            print("ì„œë²„ ì‹¤í–‰ ì¤‘...")
            await asyncio.Future()  # ë¬´í•œ ëŒ€ê¸°


async def test_client():
    """í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤íŠ¸"""
    await asyncio.sleep(1)  # ì„œë²„ ì‹œì‘ ëŒ€ê¸°

    try:
        async with websockets.connect("ws://localhost:8765") as websocket:
            print("âœ… í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì„±ê³µ")

            # í…ìŠ¤íŠ¸ ë©”ì‹œì§€
            await websocket.send("Hello!")
            response = await websocket.recv()
            print(f"ì‘ë‹µ: {response}")

            # JSON ë©”ì‹œì§€
            await websocket.send(json.dumps({"type": "ping"}))
            response = await websocket.recv()
            print(f"í•‘ ì‘ë‹µ: {response}")

            print("âœ… í…ŒìŠ¤íŠ¸ ì™„ë£Œ")

    except Exception as e:
        print(f"âŒ í´ë¼ì´ì–¸íŠ¸ ì˜¤ë¥˜: {e}")


async def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    server = SimpleWebSocketServer()

    # ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ë¥¼ ë™ì‹œì— ì‹¤í–‰
    server_task = asyncio.create_task(server.start_server())
    client_task = asyncio.create_task(test_client())

    # í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤íŠ¸ ì™„ë£Œ í›„ ì„œë²„ ì¢…ë£Œ
    await client_task
    server_task.cancel()

    try:
        await server_task
    except asyncio.CancelledError:
        pass

    print("í…ŒìŠ¤íŠ¸ ì™„ë£Œ!")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="test_websocket.py">
#!/usr/bin/env python3
"""
ì›¹ì†Œì¼“ ì„œë²„ í…ŒìŠ¤íŠ¸
"""
import asyncio
import websockets
import json


async def test_websocket():
    """ì›¹ì†Œì¼“ ì„œë²„ í…ŒìŠ¤íŠ¸"""
    try:
        # ì„œë²„ì— ì—°ê²°
        uri = "ws://localhost:8765"
        async with websockets.connect(uri) as websocket:
            print("âœ… ì„œë²„ ì—°ê²° ì„±ê³µ")

            # í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ì „ì†¡
            await websocket.send("Hello Server!")
            response = await websocket.recv()
            print(f"ì„œë²„ ì‘ë‹µ: {response}")

            # JSON ë©”ì‹œì§€ ì „ì†¡
            ping_data = {"type": "ping"}
            await websocket.send(json.dumps(ping_data))
            response = await websocket.recv()
            print(f"í•‘ ì‘ë‹µ: {response}")

            print("âœ… ì›¹ì†Œì¼“ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")

    except Exception as e:
        print(f"âŒ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")


if __name__ == "__main__":
    asyncio.run(test_websocket())
</file>

</files>
